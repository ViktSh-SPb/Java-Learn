## Что такое FetchType?

`FetchType` — это стратегия загрузки связанных сущностей или коллекций в JPA/Hibernate. Она определяет, как и когда связанные данные загружаются из базы данных:

- EAGER — жадная загрузка: связанные данные загружаются сразу при получении основной сущности.
- LAZY — ленивое (отложенное) выполнение: связанные данные загружаются только при обращении к ним.

Пример:

```java
@OneToMany(fetch = FetchType.LAZY)
private List<Order> orders;
```

---

## Какие состояния Entity существуют в Hibernate?

Состояния сущности (Entity) в Hibernate:

1. Transient (новая, несохранённая)  
    — объект создан, но ещё не сохранён в базе данных (`session.save()` не вызван).
    
2. Persistent (поддерживаемая в сессии)  
    — объект связан с текущей сессией Hibernate; изменения автоматически отслеживаются.
    
3. Detached (отключённая)  
    — объект был ранее сохранён или загружен, но сессия закрыта; изменения не отслеживаются автоматически.
    
4. Removed (удалённая)  
    — объект помечен для удаления (`session.delete()`), но ещё не выполнена команда удаления в базе.
    

---

## Что такое Hibernate и какие основные преимущества он предлагает?

Hibernate — это популярный ORM-фреймворк для Java, который реализует спецификацию JPA и добавляет свои расширения.

Преимущества Hibernate:

- Объектно-реляционное отображение (ORM).
- Автоматическая генерация SQL-запросов.
- Поддержка кэширования первого и второго уровня.
- Ленивая загрузка и каскадные операции.
- Поддержка транзакций.
- Миграция между разными базами данных без изменения бизнес-логики.
- Расширяемость и богатый функционал для сложных сценариев.

---

## Какой FetchType по умолчанию при каждой связи между двумя сущностями?

- Для `@ManyToOne` и `@OneToOne` по умолчанию — EAGER.
- Для `@OneToMany` и `@ManyToMany` по умолчанию — LAZY.

---

## Что такое каскадирование и как каскадные операции влияют на управление данными в БД?

Каскадирование (`cascade`) управляет автоматическим выполнением операций над связанными сущностями. Например, при сохранении родительской сущности можно автоматически сохранить все связанные дочерние объекты.

Пример:

```java
@OneToMany(cascade = CascadeType.ALL)
private List<Order> orders;
```

Виды каскадов:

- `PERSIST` — при сохранении родителя сохраняется и связанная сущность.
- `MERGE` — обновление связанной сущности при обновлении родителя.
- `REMOVE` — удаление связанных объектов при удалении родителя.
- `REFRESH`, `DETACH`, `ALL`.

Это упрощает управление связями, избегая ручных операций.

---

## Что такое встраиваемый (Embeddable) класс?

`Embeddable` класс — это класс, который встроен в другую сущность без отдельной таблицы. Он используется для группировки повторяющихся наборов полей.

Пример:

```java
@Embeddable
public class Address {
    private String street;
    private String city;
    // геттеры/сеттеры
}

@Entity
public class User {
    @Id
    private Long id;

    @Embedded
    private Address address;
}
```

Данные из `Address` будут храниться в той же таблице, что и `User`.

---

## Какие стратегии наследования имеются в Hibernate?

Hibernate поддерживает стандартные стратегии наследования JPA:

1. Single Table (`InheritanceType.SINGLE_TABLE`)  
    — одна таблица для всей иерархии, дискриминатор определяет тип.
    
2. Joined (`InheritanceType.JOINED`)  
    — отдельные таблицы для каждого класса, связанные по ключу.
    
3. Table per Class (`InheritanceType.TABLE_PER_CLASS`)  
    — каждая конкретная сущность имеет свою таблицу со всеми полями.
    

---

## Для чего нужны callback методы в Hibernate? К каким сущностям применяются аннотации callback методов?

Callback методы позволяют выполнять пользовательский код на определённых этапах жизненного цикла сущности:

- Перед сохранением (`@PrePersist`)
- После сохранения (`@PostPersist`)
- Перед обновлением (`@PreUpdate`)
- После обновления (`@PostUpdate`)
- Перед удалением (`@PreRemove`)
- После удаления (`@PostRemove`)
- После загрузки (`@PostLoad`)

Пример:

```java
@Entity
public class User {
    @PrePersist
    public void beforeSave() {
        // логика перед сохранением
    }
}
```

Эти методы применимы к классам-сущностям.

---

## Что такое EntityGraph?

EntityGraph позволяет динамически задавать граф связей для загрузки данных. Это помогает управлять стратегией ленивой или жадной загрузки без изменения аннотаций.

Пример использования:

```java
EntityGraph<User> graph = entityManager.createEntityGraph(User.class);
graph.addAttributeNodes("orders");
Map<String, Object> hints = new HashMap<>();
hints.put("javax.persistence.loadgraph", graph);
User user = entityManager.find(User.class, id, hints);
```

Это позволяет выбрать конкретные связи для загрузки при выполнении запроса.

---

## Какие виды кэша есть в Hibernate и какими способами?

1. Первый уровень кэша (Session cache)  
    — встроен в `Session`; действует только внутри одной сессии.
    
2. Второй уровень кэша (Second-level cache)  
    — глобальный для `SessionFactory`; кеширует данные между транзакциями/сессиями. Можно подключать внешние системы кеширования (Ehcache, Infinispan).
    
3. Query Cache  
    — кеширует результаты запросов; работает совместно со вторым уровнем кэша.
    

---

## Какие варианты настройки есть для второго уровня кэша?

- Включение второго уровня кэша через конфигурацию Hibernate:

 ```properties
- hibernate.cache.use_second_level_cache=true
hibernate.cache.region.factory_class=org.hibernate.cache.ehcache.EhCacheRegionFactory
```

- Аннотирование сущностей:

    ```java
    @Cacheable(true)
    @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
    ```
    
- Настройка стратегий кеширования:
    
    - `READ_ONLY`
    - `READ_WRITE`
    - `NONSTRICT_READ_WRITE`
    - `TRANSACTIONAL`

Это позволяет управлять уровнем конкуренции и целостностью данных в кеше.