Когда в SQL используется `GROUP BY`, агрегатные функции позволяют **собирать данные по группам**, а не по всей таблице.
## 📌 Синтаксис:
```sql
SELECT column1, 
       AGG_FUNC(column2) AS alias1,
       AGG_FUNC(column3) AS alias2
FROM table_name
GROUP BY column1;
```
- `column1` — столбец, по которому группируем.
- `AGG_FUNC` — любая агрегатная функция (`COUNT`, `SUM`, `AVG`, `MAX`, `MIN`).
## 📊 Пример 1: Основная агрегация
Таблица `employees`:

|id|department_id|salary|
|---|---|---|
|1|10|5000|
|2|10|6000|
|3|20|7000|
Запрос:
```sql
SELECT department_id,
       COUNT(*) AS employee_count,
       SUM(salary) AS total_salary,
       AVG(salary) AS avg_salary,
       MAX(salary) AS max_salary,
       MIN(salary) AS min_salary
FROM employees
GROUP BY department_id;
```
Результат:

| department_id | employee_count | total_salary | avg_salary | max_salary | min_salary |
| ------------- | -------------- | ------------ | ---------- | ---------- | ---------- |
| 10            | 2              | 11000        | 5500       | 6000       | 5000       |
| 20            | 1              | 7000         | 7000       | 7000       | 7000       |
✅ Здесь мы **объединили несколько агрегатных функций** на одной выборке с `GROUP BY`.
## 📊 Пример 2: С условием внутри агрегата
```sql
SELECT department_id,
       COUNT(*) AS total_employees,
       COUNT(CASE WHEN salary > 5000 THEN 1 END) AS high_salary_count,
       SUM(CASE WHEN salary > 5000 THEN salary END) AS high_salary_sum
FROM employees
GROUP BY department_id;
```
- `COUNT(CASE …)` и `SUM(CASE …)` позволяют применять **условия к агрегатам**.
- Отлично работает для сложной аналитики по группам.
### 💡 Советы
1. Все столбцы в `SELECT`, которые не агрегируются, **должны быть в `GROUP BY`**.
2. Можно объединять **несколько агрегатных функций на одну группу**.
3. Используй `HAVING` для фильтрации по агрегатам после группировки:
```sql
SELECT department_id, SUM(salary) AS total_salary
FROM employees
GROUP BY department_id
HAVING SUM(salary) > 10000;
```