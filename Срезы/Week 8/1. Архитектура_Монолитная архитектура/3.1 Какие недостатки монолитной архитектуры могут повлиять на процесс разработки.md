## 1️⃣ Сложность изменения кода при росте проекта
- Чем больше кодовая база, тем сложнее **понимать и изменять логику**.
- Малейшие изменения могут затронуть **несколько модулей**, что повышает риск ошибок.
## 2️⃣ Сложности с масштабированием
- Монолит масштабируется только **целиком** — нельзя отдельно увеличить мощность для одной “горячей” части приложения.
- Может потребоваться **масштабирование всей системы**, даже если нагрузка высока только на один модуль.
## 3️⃣ Долгое время сборки и деплоя
- По мере роста проекта **увеличивается время сборки и тестирования**.
- Любая небольшая правка требует **пересборки и деплоя всего монолита**.
## 4️⃣ Ограничения для командной работы
- Когда над проектом работает много разработчиков, **частые конфликты в коде** неизбежны.
- Сложно разделить работу на независимые части, потому что все изменения влияют на один артефакт.
## 5️⃣ Высокая зависимость модулей
- В монолите все компоненты тесно связаны → изменения в одном модуле могут вызвать **неожиданные эффекты** в других.
- Тестирование становится более сложным, так как нужно учитывать **взаимодействие между модулями**.
## 6️⃣ Трудности с внедрением новых технологий
- Если проект большой, сложно **заменить технологический стек** или добавить новые инструменты в одной части приложения, не затрагивая остальное.
- Например, внедрение нового языка, базы данных или фреймворка может быть дорогостоящим.
### ✅ Итог
Монолит удобен для маленьких и средних проектов, но **по мере роста приложения** эти недостатки могут замедлить разработку, усложнить тестирование, деплой и масштабирование.