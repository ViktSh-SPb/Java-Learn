## 🔹 Что такое состояние гонки (Race Condition)
**Состояние гонки (race condition)** — это ошибка в многопоточной программе, которая возникает, когда **результат работы программы зависит от порядка и скорости выполнения потоков**.
Иными словами:
- Несколько потоков обращаются к **общему ресурсу** (переменной, объекту, файлу, БД).
- Доступ **не синхронизирован**.
- Потоки могут "обгонять" друг друга, и итоговое состояние зависит от того, кто успеет первым.
В результате — **непредсказуемое поведение** и ошибки, которые трудно воспроизводить.
## 🔹 Простой пример
```java
public class RaceConditionExample {
    private static int counter = 0;

    public static void main(String[] args) throws InterruptedException {
        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter++; // общий ресурс
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);

        t1.start();
        t2.start();
        t1.join();
        t2.join();

        System.out.println("Итоговое значение: " + counter);
    }
}
```
👉 Ожидаем `2000`, но результат может быть меньше (например, `1743`).
## 🔹 Почему так происходит?
Операция `counter++` **не атомарна**:
1. поток читает значение `counter`,
2. увеличивает его на 1,
3. записывает обратно.
Если два потока выполнят шаги **одновременно**, один из инкрементов "потеряется".
## 🔹 Как избежать состояния гонки
1. **Синхронизация (`synchronized`)**
    ```java
    synchronized(lock) {
        counter++;
    }
    ```
2. **Использование атомарных классов (`AtomicInteger`)**
    ```java
    private static AtomicInteger counter = new AtomicInteger(0);
    counter.incrementAndGet();
    ```
3. **Использование высокоуровневых синхронизаторов**  
    (`ReentrantLock`, `Semaphore`, `CountDownLatch`, `Phaser`, `CyclicBarrier`).
4. **Иммутабельность и локальные данные**
    - Делать данные неизменяемыми.
    - Или передавать каждому потоку свою копию (`ThreadLocal`).