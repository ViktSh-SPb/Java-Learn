В **Java Memory Model (JMM)** семантика **happens-before** описывает порядок операций и видимость изменений между потоками. Когда мы используем **`Lock` и `Condition`** из `java.util.concurrent.locks`, JMM гарантирует корректное взаимодействие потоков через эти конструкции.
### 1️⃣ Основная идея happens-before с Lock
- **Вход в блокировка (`lock.lock()`)** и **выход из блокировки (`lock.unlock()`)** создают **happens-before отношение**:
    - Любые изменения переменных **до `unlock()`** одного потока **видны** любому потоку после `lock()` той же блокировки.
```java
Lock lock = new ReentrantLock();
int shared = 0;

void writer() {
    lock.lock();
    try {
        shared = 42; // запись
    } finally {
        lock.unlock(); // выход happens-before
    }
}

void reader() {
    lock.lock();       // вход happens-after
    try {
        int value = shared; // чтение видит 42
    } finally {
        lock.unlock();
    }
}
```
✅ Гарантия: поток `reader` увидит изменения `shared`, сделанные потоком `writer`.
### 2️⃣ Semantics с `Condition`
- `Condition` используется для ожидания и уведомления между потоками.
- Основные методы:
    - `await()` — поток освобождает lock и ждет сигнала.
    - `signal()` / `signalAll()` — уведомляет один/все ожидающие потоки.
#### Happens-before правила:
1. Вызов `signal()` **happens-before** возвращением из `await()` потока, который был разбужен.
2. Любые изменения переменных **до `signal()`** будут видны потоку после `await()`.
```java
Lock lock = new ReentrantLock();
Condition cond = lock.newCondition();
boolean ready = false;

void writer() {
    lock.lock();
    try {
        ready = true; // изменение состояния
        cond.signal(); // happens-before для потока, проснувшегося из await()
    } finally {
        lock.unlock();
    }
}

void reader() throws InterruptedException {
    lock.lock();
    try {
        while (!ready) {
            cond.await(); // ждет сигнал
        }
        // После await() гарантированно видит ready = true
    } finally {
        lock.unlock();
    }
}
```
✅ Гарантия: поток `reader` видит все изменения, сделанные до `signal()`.
### 3️⃣ Вывод
- **Lock / unlock** создают happens-before для **всех переменных, защищённых этой блокировкой**.
- **Condition.await() / signal()** создают happens-before между **потоком, который послал сигнал, и потоком, который проснулся**.
- Это обеспечивает:
    1. **Корректную видимость данных** между потоками.
    2. **Синхронизацию порядка выполнения**, предотвращая гонки и проблемы reordering.