### Какой класс в Java используется для создания нового потока?

Основной класс — `java.lang.Thread`. Он представляет поток выполнения и позволяет запускать код параллельно с другими потоками.

### Каким образом можно создать поток, используя интерфейс Runnable?

Можно реализовать интерфейс `Runnable` и передать его экземпляр в конструктор `Thread`:

```java
Runnable task = () -> {
    // код, который нужно выполнить в потоке
};
Thread thread = new Thread(task);
thread.start();
```

или:

```java
class MyTask implements Runnable {
    public void run() {
        // код задачи
    }
}
Thread thread = new Thread(new MyTask());
thread.start();
```

### Чем отличается создание потока с использованием класса Thread от создания с использованием интерфейса Runnable?

- Создание через `Thread`: расширяете класс `Thread` и переопределяете метод `run()`. Это наследование — ограничение, так как класс уже наследует `Thread`.
- Создание через `Runnable`: реализуете интерфейс `Runnable`, что позволяет использовать композицию и избегать ограничения наследования. Это более гибко и рекомендуется для разделения логики выполнения от управления потоком.

### Как можно создать поток, используя лямбда-выражения?

Лямбда-выражения позволяют писать компактный код:

```java
Thread thread = new Thread(() -> {
    // код, выполняемый в новом потоке
});
thread.start();
```

### В чем преимущество использования интерфейса Callable по сравнению с Runnable при создании потоков?

- `Callable` позволяет возвращать результат выполнения (`V call()`) и выбрасывать исключения.
- В отличие от `Runnable`, который возвращает `void`, `Callable` подходит для задач, где нужен результат.
- Для получения результата из `Callable` используют `FutureTask`.

Пример:

```java
Callable<Integer> task = () -> {
    // вычисления
    return 42;
};
Future<Integer> future = Executors.newSingleThreadExecutor().submit(task);
Integer result = future.get(); // получение результата
```

### Как использовать пул потоков для управления множеством потоков в Java?

Используйте классы из пакета `java.util.concurrent`, например, `ExecutorService`:

```java
ExecutorService executor = Executors.newFixedThreadPool(4);
executor.submit(() -> {
    // задача
});
executor.shutdown(); // завершение работы пула
```

Это управляет количеством одновременно выполняемых потоков и переиспользует их.

### Как реализовать паттерн Producer-Consumer с использованием многопоточности в Java?

Используйте механизмы синхронизации, такие как блокировки (`synchronized`) или классы из пакета `java.util.concurrent`, например, `BlockingQueue`:

```java
BlockingQueue<String> queue = new ArrayBlockingQueue<>(10);

class Producer implements Runnable {
    public void run() {
        try {
            queue.put("item");
        } catch (InterruptedException e) { }
    }
}

class Consumer implements Runnable {
    public void run() {
        try {
            String item = queue.take();
            // обработка item
        } catch (InterruptedException e) { }
    }
}
```

Это обеспечивает безопасную передачу данных между потоками без явных блокировок.

### Какие механизмы синхронизации потоков можно использовать при реализации многопоточных приложений?

- synchronized: для блокировки критических секций.
- ReentrantLock: более гибкий механизм блокировок.
- volatile: для обеспечения видимости изменений переменных между потоками.
- Atomic переменные (`AtomicInteger`, `AtomicLong`): для атомарных операций.
- CountDownLatch, CyclicBarrier, Semaphore: для координации работы нескольких потоков.

### Какие существуют способы управления состоянием потоков в Java и как они влияют на производительность приложения?

Потоки могут находиться в состояниях: NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED. Управление состоянием включает:

- Использование методов `.join()`, `.sleep()`, `.wait()`, `.notify()` для контроля выполнения.
- Внимательное управление блокировками — избежание взаимных блокировок (deadlocks).
- Использование пулов потоков (`ExecutorService`) вместо создания новых потоков — повышает производительность за счёт повторного использования ресурсов.

Эффективное управление состоянием помогает снизить накладные расходы и повысить отзывчивость приложения.