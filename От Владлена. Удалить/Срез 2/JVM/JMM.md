### Что такое Java Memory Model (JMM)?

Java Memory Model — это спецификация, которая определяет, как потоки взаимодействуют с памятью и как гарантируется согласованность данных при параллельном выполнении. Она описывает правила, по которым операции чтения и записи в память могут происходить, а также гарантии видимости и порядка выполнения. JMM обеспечивает правильное взаимодействие между потоками, предотвращая ошибки, связанные с неконсистентным состоянием данных.

### Для чего используется ключевое слово volatile в Java?

Ключевое слово `volatile` используется для объявления переменной, чтобы обеспечить:

- Гарантированную видимость: изменения переменной в одном потоке сразу становятся видимыми другим потокам.
- Запрет reorderings: операции чтения/записи с `volatile` не могут быть переупорядочены относительно других операций с этой переменной. Это делает `volatile` легким механизмом для обмена флагами или состояниями без необходимости использования блокировок.

### Что означает “visibility” (видимость) в контексте JMM?

Видимость — это гарантия того, что изменения, сделанные одним потоком к переменной, станут доступны другим потокам. Без правильных механизмов (например, `volatile`, `synchronized`) один поток может изменить значение переменной, но другой поток может продолжать видеть старое значение из кэша или регистров процессора.

### Каким образом ключевое слово synchronized влияет на видимость и порядок выполнения?

`Synchronized`:

- Обеспечивает гарантированную видимость: все изменения внутри блока `synchronized` становятся видимыми после выхода из блока.
- Обеспечивает упорядочивание операций: операции внутри синхронизированного блока не могут быть переупорядочены относительно других операций внутри этого блока.
- Входит в понятие happens-before: завершение одного блока `synchronized` гарантирует, что все его действия будут видимы другим потокам, которые войдут в блок `synchronized` на том же объекте.

### В чем разница между synchronized и volatile?

|Аспект|`volatile`|`synchronized`|
|---|---|---|
|Видимость|Гарантирует мгновенную видимость изменений|Гарантирует мгновенную видимость изменений|
|Порядок выполнения|Запрещает reorderings вокруг обращения к переменной|Обеспечивает полный барьер памяти (включая порядок)|
|Механизм|Только для отдельных переменных|Блокировки для критических секций|
|Производительность|Легкий механизм, менее затратный|Более тяжелый из-за блокировок|
|Использование|Для флагов или статусов|Для критических секций и взаимного исключения|

### Какую роль играют happens-before отношения в JMM? Приведите пример.

Отношение happens-before определяет порядок выполнения операций между потоками:

- Если операция A "happens-before" операции B, то все эффекты A гарантированно видны B.
- Например:

```java
synchronized(lock) {
    // операция A
    sharedVar = 42; // запись
}
// операция B
synchronized(lock) {
    int value = sharedVar; // чтение
}
```

Здесь запись внутри первого блока происходит до чтения во втором — благодаря отношению happens-before через синхронизированные блоки. Это гарантирует, что чтение увидит обновленное значение.

### Какие гарантии предоставляет JMM при использовании атомарных классов из пакета java.util.concurrent?

Атомарные классы (`AtomicInteger`, `AtomicLong`, и т.д.) предоставляют:

- Гарантированную атомарность операций (например, `incrementAndGet()`).
- Видимость изменений между потоками без необходимости использования `synchronized`.
- Они используют низкоуровневые примитивы (например, compare-and-swap), чтобы обеспечить корректность без блокировок.

### Что такое “reordering” и как оно влияет на многопоточность в Java?

Reordering — это оптимизация компилятора или процессора, при которой операции меняют порядок выполнения для повышения производительности. В однопоточном контексте это безопасно, но в многопоточном может привести к ситуациям:

- Поток читает данные до их фактической записи другим потоком.
- Нарушается логика синхронизации. Чтобы избежать этого, используют механизмы памяти (`volatile`, `synchronized`) или атомарные операции.

### Как работает final в контексте JMM, и как это влияет на безопасную публикацию объектов?

Объявление объекта или его полей как `final`:

- Гарантирует безопасную публикацию: после конструктора объект полностью инициализирован перед передачей другому потоку.
- После завершения конструктора все потоки увидят правильно сконфигурированный объект без дополнительных мер синхронизации. Это важно для предотвращения ситуаций с частичной инициализацией.

### Какие существуют способы публикации объекта между потоками? Примеры.

1. Через синхронизированные блоки (`synchronized`)
2. Через volatile-переменные
3. Через атомарные классы (`AtomicReference`)
4. Через статические начальные блоки или классы с ленивой загрузкой
5. Использование методов типа `publish()` из java.util.concurrent

Пример:

```java
// Публикация через volatile
public class SafePublish {
    private volatile Data data;

    public void publish() {
        data = new Data();
    }

    public Data getData() {
        return data;
    }
}
```

### Объясните влияние JMM на сборщик мусора (Garbage Collector) и его взаимодействие с потоками.

JMM обеспечивает правильное взаимодействие потоков с памятью при сборке мусора:

- Объекты считаются достижимыми или недостижимыми согласно happens-before.
- GC не удалит объекты до тех пор, пока они доступны через действия другого потока.
- Внутренние механизмы GC учитывают порядок публикации объектов (например, через `final` или `volatile`) для корректной работы.

### Как можно добиться безопасного завершения потоков в Java с учетом JMM?

Используйте:

- Флаги типа `volatile boolean running = true;`
- Или методы типа `interrupt()`, совместно с проверкой состояния (`Thread.currentThread().isInterrupted()`) Пример:

```java
public class Worker extends Thread {
    private volatile boolean running = true;

    public void run() {
        while (running) {
            // работа
        }
    }

    public void stopRunning() {
        running = false; // гарантия видимости благодаря volatile
    }
}
```

### Какие проблемы могут возникнуть при неправильно настроенном lazy initialization в многопоточности? Как их решить?

Проблемы:

- Потенциальная частичная инициализация объекта (видит неинициализированные поля).
- Двойная инициализация при использовании небезопасных методов. Решения:
- Использовать `volatile` для переменной singleton.
- Использовать двойную проверку блокировки (`double-check locking`) с правильной реализацией.
- Использовать статические внутренние классы (`Initialization-on-demand holder idiom`).

### Объясните семантику happens-before в контексте чтения и записи с использованием Lock и Condition.

При использовании Lock/Condition:

- Вызов `lock()` устанавливает отношение happens-before между предыдущими действиями этого потока и последующим входом в критическую секцию.
- Вызов `unlock()` устанавливает отношение happens-before к любым действиям другого потока после его вызова на том же объекте Lock. Пример:

```java
lock.lock();
// запись данных
sharedVar = 42;
lock.unlock();

lock.lock();
// чтение данных
int value = sharedVar; // гарантировано увидит 42
lock.unlock();
```

Здесь порядок вызова lock/unlock обеспечивает правильную видимость данных между потоками.