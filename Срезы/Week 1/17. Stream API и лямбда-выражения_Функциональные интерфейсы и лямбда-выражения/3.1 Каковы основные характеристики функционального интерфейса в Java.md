## 1. Ровно один абстрактный метод
Это **ключевое и обязательное** условие.
```java
@FunctionalInterface
interface Action {
    void execute();
}
```
Если абстрактных методов станет больше одного — интерфейс перестаёт быть функциональным.
## 2. Может содержать `default`- и `static`-методы
Они **не учитываются** при подсчёте абстрактных методов.
```java
@FunctionalInterface
interface Printer {
    void print(String s);

    default void log() {}
    static void info() {}
}
```
## 3. Методы `Object` не учитываются
Методы `equals`, `hashCode`, `toString` **не нарушают** функциональность интерфейса.
```java
@FunctionalInterface
interface Test {
    void run();

    @Override
    String toString();
}
```
## 4. Может быть реализован лямбдой или method reference
Функциональный интерфейс — **тип** для лямбда-выражений.
```java
Runnable r = () -> System.out.println("Hello");
Consumer<String> c = System.out::println;
```
## 5. Поддерживает `@FunctionalInterface`
Аннотация:
- не обязательна
- гарантирует проверку компилятором
- документирует намерение
```java
@FunctionalInterface
interface Calculator {
    int sum(int a, int b);
}
```
## 6. Поддерживает вывод типов (type inference)
Тип параметров лямбды определяется из сигнатуры метода интерфейса.
```java
Predicate<Integer> p = x -> x > 0;
```
## 7. Может быть обобщённым (generic)
```java
@FunctionalInterface
interface Converter<T, R> {
    R convert(T value);
}
```
## 8. Часто используется в стандартной библиотеке
Пакет `java.util.function` содержит набор стандартных функциональных интерфейсов:
- `Predicate`
- `Function`
- `Consumer`
- `Supplier`
- `UnaryOperator`
- `BinaryOperator`
## Краткий ответ
> Функциональный интерфейс в Java содержит ровно один абстрактный метод, может иметь `default` и `static` методы, методы `Object` не учитываются и используется как тип для лямбда-выражений и ссылок на методы.