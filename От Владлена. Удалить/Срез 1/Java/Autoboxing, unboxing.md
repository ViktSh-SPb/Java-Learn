### Что такое автоупаковка (autoboxing) и автораспаковка (unboxing) в Java?

- **Автоупаковка (autoboxing)** — автоматическое преобразование примитивного типа в его обертанный класс. Например, преобразование `int` в `Integer`.
- **Авторспаковка (unboxing)** — автоматическое преобразование объекта обертанного типа обратно в примитивный тип.

---

### Какие типы данных поддерживают операции автоупаковки и автораспаковки в Java?

- Поддерживаются все примитивные типы и их соответствующие классы-обертки:
  - `byte` / `Byte`
  - `short` / `Short`
  - `int` / `Integer`
  - `long` / `Long`
  - `float` / `Float`
  - `double` / `Double`
  - `char` / `Character`
  - `boolean` / `Boolean`

---

### Приведите пример использования автоупаковки в Java.

```java
int primitiveInt = 5;
Integer wrappedInt = primitiveInt; // автоупаковка
````

или при использовании коллекций:

```java
List<Integer> list = new ArrayList<>();
list.add(10); // автоупаковка int в Integer
```

### Какая основная разница между примитивными типами и их оберточными классами в контексте автоупаковки и автораспаковки?

- Примитивные типы — занимают меньше памяти, не имеют методов.
- Обертки — объекты, предоставляющие методы для работы с данными, могут быть использованы в коллекциях.
- В контексте автоупаковки/автораспаковки:
    - Примитивы автоматически превращаются в объекты (`autoboxing`) при необходимости.
    - Объекты автоматически преобразуются обратно в примитивы (`unboxing`) при использовании.

### Как операция автораспаковки может привести к исключению NullPointerException?

- Если объект обертанного типа равен `null`, то при попытке его распаковать (`unboxing`) произойдет исключение:

```java
Integer nullInteger = null;
int value = nullInteger; // NullPointerException
```

### Каким образом использование автоупаковки и автораспаковки влияет на производительность приложения?

- В большинстве случаев автоматические преобразования незначительно влияют на производительность.
- Однако при частых операциях внутри циклов или критичных по скорости участках:
    - Постоянное создание новых объектов оберток (например, при автозаключении) может привести к увеличению нагрузки на сборщик мусора.
    - Лучше избегать избыточной автоупаковки/автораспаковки там, где важна высокая производительность.

### Объясните, как работает кэширование при автоупаковке целочисленных типов данных в Java.

- Для значений от `-128` до `127` встроен кэш объектов типа `Integer`. При автозаключении для чисел из этого диапазона возвращается один и тот же объект из кэша.
- Это позволяет экономить память и ускоряет сравнение с помощью ==:

```java
Integer a = 100; // использует кэш
Integer b = 100;
System.out.println(a == b); // true

Integer c = 200; // не из кэша
Integer d = 200;
System.out.println(c == d); // false
```

### Какие потенциальные проблемы могут возникнуть при сравнении объектов оберточных классов, полученных через автоупаковку?

- Использование оператора `==` сравнивает ссылки, а не значения объектов.
- Для сравнения значений нужно использовать `.equals()`:

```java
Integer a = 128;
Integer b = 128;
System.out.println(a == b); // false (ссылки разные)
System.out.println(a.equals(b)); // true (значения равны)
```

### В каких случаях предпочтительно избегать автоупаковки и автораспаковки для оптимизации производительности приложения?

- В критичных по скорости участках кода, особенно внутри циклов.
- Когда происходит множество операций сравнения или арифметических действий с объектами оберток.
- При работе с большими объемами данных или в системах с ограниченными ресурсами.

Лучше использовать примитивные типы напрямую, избегая лишних преобразований.