### 1️⃣ Атомарность операций
- Все стандартные методы атомарных классов (`getAndIncrement()`, `compareAndSet()`, `incrementAndGet()` и т.д.) выполняются **атомарно**, т.е. **нельзя наблюдать промежуточное состояние**.
- Пример: `AtomicInteger.incrementAndGet()` — никакой другой поток не увидит «половину» инкремента.
```java
AtomicInteger counter = new AtomicInteger(0);
counter.incrementAndGet(); // атомарно, безопасно для потоков
```
### 2️⃣ Видимость изменений (Visibility)
- Атомарные классы **гарантируют видимость изменений между потоками** без явного использования `volatile` или `synchronized`.
- Все операции **happens-before** друг относительно друга при чтении/записи через атомарные методы.
```java
AtomicBoolean flag = new AtomicBoolean(false);

// Поток 1
flag.set(true); // запись видна другим потокам

// Поток 2
if (flag.get()) { // чтение гарантированно видит изменения
}
```
### 3️⃣ Поддержка **Happens-Before**
- Все атомарные методы создают **happens-before** отношения:
    - Запись атомарного значения happens-before любому последующему чтению этого значения.
- Это значит, что **любые изменения, сделанные до `set()` или через CAS, будут видны другим потокам**, использующим атомарный объект.
### 4️⃣ Не блокирующая синхронизация
- Атомарные классы используют **CAS (Compare-And-Swap) или другие неблокирующие механизмы**.
- Это снижает накладные расходы и **исключает блокировки**, в отличие от `synchronized`.
### ⚡ Итог
Атомарные классы гарантируют:
1. **Атомарность** операций.
2. **Видимость** изменений между потоками.
3. **Happens-before** для операций чтения/записи.
4. **Неблокирующий подход**, что улучшает производительность.