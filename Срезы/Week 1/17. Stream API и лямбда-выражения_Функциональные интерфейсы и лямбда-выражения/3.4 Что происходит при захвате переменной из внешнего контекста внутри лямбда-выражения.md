При **захвате переменной из внешнего контекста** (variable capture) лямбда-выражение в Java **захватывает не саму переменную, а её значение**. Из-за этого действуют строгие правила.
## 1. Что именно происходит
Если лямбда использует локальную переменную:
```java
int x = 10;

Runnable r = () -> System.out.println(x);
```
происходит следующее:
1. Компилятор проверяет, что `x` — **final или effectively final**
2. Значение `x` **копируется** во внутреннее представление лямбды
3. Лямбда **не имеет доступа к самой переменной**, только к её значению
Поэтому изменить `x` нельзя.
## 2. Почему переменная должна быть `final / effectively final`
❌ Нельзя:
```java
int x = 10;

Runnable r = () -> {
    // x++;
};
```
Ошибка компиляции:
```
Local variable x defined in an enclosing scope must be final or effectively final
```
Причины:
- лямбда может выполниться **позже**
- возможно выполнение в **другом потоке**
- стековый фрейм метода уже уничтожен
## 3. Что значит _effectively final_
Переменная:
- инициализируется один раз
- после этого **не меняется**
```java
int y = 5;

if (condition) {
    y = 5; // допустимо
}

Runnable r = () -> System.out.println(y); // ✔
```
## 4. Захват полей класса
Поля класса **захватываются по ссылке**, а не по значению:
```java
class Counter {
    int count = 0;

    Runnable r = () -> count++;
}
```
✔ изменять можно  
❗ ответственность за потокобезопасность — на разработчике
## 5. Захват изменяемых объектов
Можно изменять **состояние объекта**, если ссылка на него effectively final:
```java
AtomicInteger count = new AtomicInteger(0);

Runnable r = () -> count.incrementAndGet();
```
❗ меняется объект, а не ссылка
## 6. Отличие от анонимных классов
Поведение одинаково:
- локальные переменные должны быть effectively final
Но есть отличие:
- у лямбды **нет собственного `this`**
- `this` указывает на внешний класс
## 7. Что происходит на уровне JVM (кратко)
- лямбда компилируется через `invokedynamic`
- захваченные значения передаются как **скрытые параметры**
- создаётся экземпляр функционального интерфейса
## 8. Типичные ошибки
- попытка изменить локальную переменную
- ожидание «живой» связи с переменной
- игнорирование потокобезопасности при захвате полей