# Иерархия коллекций в Java

```mermaid
%% Иерархия коллекций Java (интерфейсы и классы)
classDiagram
  %% ===== Интерфейсы =====
  class Iterable:::interface
  class Collection:::interface
  class List:::interface
  class Set:::interface
  class SortedSet:::interface
  class Queue:::interface
  class Deque:::interface


  %% ===== Классы =====
  class ArrayList:::clazz
  class LinkedList:::clazz
  class Vector:::clazz
  class Stack:::clazz
  class HashSet:::clazz
  class LinkedHashSet:::clazz
  class TreeSet:::clazz
  class PriorityQueue:::clazz
  class ArrayDeque:::clazz

  %% ===== Наследование Collection =====
  Iterable <|-- Collection
  Collection <|-- List
  Collection <|-- Set
  Collection <|-- Queue
  List <|.. ArrayList
  List <|.. LinkedList
  List <|.. Vector
  Vector <|-- Stack
  Set <|.. HashSet
  Set <|.. LinkedHashSet
  Set <|-- SortedSet
  SortedSet <|.. TreeSet
  Queue <|.. PriorityQueue
  Queue <|-- Deque
  Deque <|.. ArrayDeque

classDef interface fill:#fdbf6e,stroke:#f66,stroke-width:2px,color:#111,stroke-dasharray: 10 5
classDef clazz fill:#aec670,stroke:#5ba199,stroke-width:2px,color:#111
```
# Set
**Set** - это интерфейс в Java, который представляет собой коллекцию, не содержащую дубликатов элементов.
## Основные характеристики:
- Не допускает дублирования элементов (все элементы уникальны)
- Может содержать не более одного *null* элемента.
- Не гарантирует порядок элементов (за исключением некоторых реализаций)
## Основные реализации Set:
### 1. HashSet:
- Наиболее часто используемая реализация
- Хранит элементы в хэш-таблице
- Не гарантирует порядок элементов
- Обеспечивает быстрый доступ к элементам (*О(1)* для основных операций)
- Потокобезопасна
```java
Set<String> hashSet = new HashSet<>();
hashSet.add("Apple");
hashSet.add("Banana");
hashSet.add("Apple"); // Не будет добавлено
```
### 2. LinkedHashSet:
- Сохраняет порядок вставки элементов
- Для хранения элементов используется комбинация связного списка и хэш-таблицы
- Немного медленнее *HashSet* из-за дополнительных затрат на поддержание связного списка
- Полезен когда важен порядок итерации
```java
Set<String> linkedHashSet = new LinkedHashSet<>();
linkedHashSet.add("First");
linkedHashSet.add("Second");
linkedHashSet.add("Third");
// Итерация будет в порядке добавления
```
### 3. TreeSet
- Хранит элементы в отсортированном порядке (по возрастанию)
- Реализован на основе красно-черного дерева
- Время выполнения операции *О(log n)*
- Может использовать Comparator для сортировки
```java
Set<String> treeSet = new TreeSet<>();
treeSet.add("Zebra");
treeSet.add("Apple");
treeSet.add("Banana");
// Элементы будут отсортированы: Apple, Banana, Zebra
```
## Основные методы Set:
- **add(E e)** - добавляет элемент, если его еще нет в множестве
- **remove(Object o)** - удаляет указанный элемент
- **contains(Object o)** - проверяет наличие элемента
- **size()** - возвращает количество элементов
- **isEmpty()** - возвращает логический ответ, пуст ли набор
- **clear()** - удаляет все элементы
- **iterator()** - возвращает итератор по элементам
## Особенности использования:
1. Проверка на дубликаты: *Set* использует методы *equals() и hashCode()* для определения дубликатов. Поэтому важно правильно их реализовать для объектов, которые вы храните в *Set*.
2. Сравнение с *List*:
	- *List* допускает дубликаты, *Set* - нет.
	- *List* сохраняет порядок вставки (кроме некоторых реализаций), *Set* - не всегда
	- Доступ по индексу есть только в *List*
3. Потокобезопасность: Стандартные реализации *Set* не потокобезопасны. Для многопоточного доступа можно использовать:
	- `Collections.synchronizedSet(new HashSet<>())`
	- `CopyOnWriteArraySet` (для редко изменяемых наборов)
	- `ConcurrentHashMap.newKeySet()`
# ArrayList
**ArrayList** - это реализация динамического массива, который позволяет хранить элементы и автоматически изменять свой размер при добавлении или удалении элементов. Это одна из самых популярных коллекций в Java, так как она сочетает в себе удобство списка и эффективность массива.
## Основные характеристики ArrayList
- ✅ **Динамический размер** - автоматически расширяется при добавлении элементов.
- ✅ **Быстрый доступ по индексу** - *О(1)* (как в обычном массиве).
- ✅ **Поддержка generics** - типобезопасность (*ArrayList\<Integer>, ArrayList\<String>*).
- ✅ **Допускает null и дубликаты**.
- ❌ **Медленная вставка/удаление в середину** - *О(n)* (из-за сдвига элементов).
## Внутреннее устройство ArrayList
Внутри *ArrayList* хранит элементы в обычном массиве (*Object[]*).
- При создании *ArrayList* имеет начальную емкость (10)
- Если массив заполняется, происходит расширение (*resize*) - создается новый массив в 1.5 раза больше (в *Java 7+*) и копируются старые элементы.
## Основные операции и их сложность

| Операция                | Сложность (О)               | Пояснение                                    |
| ----------------------- | --------------------------- | -------------------------------------------- |
| get(index)              | O(1)                        | Прямой доступ к элементу                     |
| add(element)            | O(1)&nbsp(амортизированная) | Добавление в конец, если места хватает       |
| add(index,&nbspelement) | O(n)                        | Вставка в середину требует сдвига элементов  |
| remove(index)           | O(n)                        | Удаление по индексу требует сдвига элементов |
| remove(Object)          | O(n)                        | Поиск элемента + сдвиг                       |
| contains(Object)        | O(n)                        | Линейный поиск (нет хеширования)             |
| set(index, element)     | O(1)                        | Замена элемента по индексу                   |
## Создание ArrayList
```java
import java.util.ArrayList

// 1. Создание пустого списка (начальная емкость = 10)
ArrayList<String> list1 = new ArrayList<>();

// 2. Создание с указанием начальной емкости (оптимизация, если известно количество элементов)
ArrayList<Integer> list2 = new ArrayList<>(100);

// 3. Создание из другой коллекции
ArrayList<String> list3 = new ArrayList<>(List.of("A", "B", "C"));
```
## Основные методы
### 1. Добавление элементов
```java
ArrayList<String> fruits = new ArrayList<>();
fruits.add("Apple");       // ["Apple"]
fruits.add("Banana");      // ["Apple", "Banana"]
fruits.add(1, "Orange");   // ["Apple", "Orange", "Banana"] (вставка по индексу)
```
### 2. Получение элементов
```java
String first = fruits.get(0); // Apple
int size = fruits.size();     // 3
```
### 3. Удаление элементов
```java
fruits.remove(0);         // Удаляет "Apple" ⟶ ["Orange", "Banana"]
fruits.remove("Banana");  // Удаляет "Banana" ⟶ ["Orange"]
fruits.clear();           // Очищает список ⟶ []
```
### 4. Проверка наличия элементов
```java
boolean hasApple = fruits.contains("Apple"); // false
int index = fruits.indexOf("Orange");        // 0
```
### 5. Итерация по ArrayList
```java
// через for-each
for (String fruit : fruits) {
	System.out.println(fruit);
}

// через for + индекс
for (int i = 0; i < fruits.size(); i++) {
	System.out.println(fruits.get(i));
}

// через итератор
Iterator<String> it = fruits.iterator();
while (it.hasNext()) {
	System.out.println(it.next());
}
```
## Преимущества и недостатки
### ✅Плюсы:
- Быстрый доступ по индексу (*get, set*)
- Удобные методы для работы с данными (*add, remove, contains*)
- Гибкость (размер меняется автоматически)
### ❌Минусы:
- Медленные вставка и удаление в середину (*О(n)*)
- Тратит дополнительную память (резервирует место в массиве)
- Не синхронизирован (не потокобезопасен, в отличие от *Vector*)
