**Функциональные интерфейсы**  - это интерфейсы, которые содержат один и только один абстрактный метод (*SAM - single abstract method*). Они появились в Java 8 и стали основой для работы с лямбда-выражениями.
# Основные особенности
1. Один абстрактный метод - главное условие
2. Могут иметь *default* и *static* методы - они не считаются абстрактными
3. Аннотация *@FunctionalInterface* - не обязательна, но помогает компилятору проверять, что интерфейс действительно функциональный
# Примеры стандартных функциональных интерфейсов (из java.util.function)
### 1. Predicate\<T>
Проверяет условие: `boolean test(T t)`
#### Пример:
```java
Predicate<Integer> isEven = num -> num % 2 == 0
System.out.println(isEven(4)); // true
```
### 2. Function<T, R>
Преобразует **T** в **R**: `R apply(T t)`
#### Пример:
```java
Function<String, Integer> strLength = s -> s.length();
System.out.println(strLength.apply("Hello")); // 5
```
### 3. Consumer\<T>
Принимает **T**, ничего не возвращает: `void accept(T t)`
#### Пример:
```java
Consumer<String> printUpperCase = s -> System.out.println(s.toUpperCase());
printUpperCase.accept("java"); // "JAVA"
```
### 4. Supplier\<T>
Поставляет значение: `T get()`
#### Пример:
```java
Supplier<Double> randomValue = () -> Math.random();
System.out.println(randomValue.get()); // Случайное число
```
### 5. UnaryOperator\<T> (частный случай Function<T, T>)
Принимает и возвращает **T**: `T apply(T t)`
#### Пример:
```java
UnaryOperator<Integer>square = x -> x*x;
System.out.println(square.apply(5)); // 25
```
### 6. BiFunction<T, U, R>
Принимает **T** и **U**, возвращает **R**: `R apply(T t, U u)`
#### Пример:
```java
BiFunction<Integer, Integer, Integer> sum = (a, b) -> a + b;
System.out.println(sum.apply(3,5)); // 8
```
# Создание своего функционального интерфейса
```java
@FunctionalInterface
interface StringProcessor {
	String process(String input);

	default void printInfo() {
		System.out.println("Это функциональный интерфейс!");
	}
}

public class Main {
	public static void main(String[] args) {
		StringProcessor toUpper = s -> s.toUpperCase();
		System.out.println(toUpper.process("hello")); // "HELLO"
		toUpper.printInfo(); // "Это функциональный интерфейс!"
	}
}
```
# Зачем нужны?
- **Лямбда-выражения** - позволяют писать более краткий и читаемый код
- **Стримы (Stream API)** - большинство операций (map, filter, reduce) принимают функциональные интерфейсы
- **Параллельное программирование** - упрощают работу с CompletableFuture и другими API

### 1 **Predicate\<T>** — Предикат (проверка условия)
**Описание:** проверяет условие и возвращает `true` или `false`.
```java
Predicate<T>
```
**Абстрактный метод:**
```java
boolean test(T t);
```
### 2 **Function<T, R> — Функция преобразования**
**Описание:** преобразует значение типа `T` в значение типа `R`.
```java
Function<T, R>
```
**Абстрактный метод:**
```java
R apply(T t);
```
### 3 **Consumer\<T>** — Потребитель (действие)
**Описание:** принимает значение и выполняет действие, ничего не возвращая.
```java
Consumer<T>
```
**Абстрактный метод:**
```java
void accept(T t);
```
### 4 **Supplier\<T>** — Поставщик значения
**Описание:** не принимает аргументов, возвращает значение.
```java
Supplier<T>
```
**Абстрактный метод:**
```java
T get();
```
### 5 **UnaryOperator\<T>** — Унарный оператор
**Описание:** преобразует значение в значение того же типа (`T → T`).
```java
UnaryOperator<T>
```
**Абстрактный метод:**
```java
T apply(T t);
```
### 6 **BinaryOperator\<T>** — Бинарный оператор
**Описание:** выполняет операцию над двумя значениями одного типа.
```java
BinaryOperator<T>
```
**Абстрактный метод:**
```java
T apply(T t1, T t2);
```
### 7 **BiFunction<T, U, R>** — Функция от двух аргументов
**Описание:** принимает два аргумента разных типов и возвращает результат.
```java
BiFunction<T, U, R>
```
**Абстрактный метод:**
```java
R apply(T t, U u);
```
### 9 **BiPredicate<T, U>** — Предикат от двух аргументов
**Описание:** проверяет условие для двух значений.
```java
BiPredicate<T, U>
```
**Абстрактный метод:**
```java
boolean test(T t, U u);
```
### 9 **BiConsumer<T, U>** — Потребитель двух аргументов
**Описание:** выполняет действие над двумя значениями.
```java
BiConsumer<T, U>
```
**Абстрактный метод:**
```java
void accept(T t, U u);
```
### 10 **Comparator\<T>** — Компаратор (сравнение)
**Описание:** сравнивает два объекта для сортировки.
```java
Comparator<T>
```
**Абстрактный метод:**
```java
int compare(T o1, T o2);
```
### 11 **Runnable** — Выполняемая задача
**Описание:** представляет задачу без результата и исключений.
```java
Runnable
```
**Абстрактный метод:**
```java
void run();
```
### 12 **Callable\<V>** — Задача с результатом
**Описание:** представляет задачу, возвращающую результат и допускающую исключения.
```java
Callable<V>
```
**Абстрактный метод:**
```java
V call() throws Exception;
```