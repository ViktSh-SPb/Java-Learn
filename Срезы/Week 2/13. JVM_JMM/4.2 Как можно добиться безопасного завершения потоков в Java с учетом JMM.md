В **Java** безопасное завершение потоков тесно связано с **видимостью изменений между потоками**, определяемой **Java Memory Model (JMM)**. Простое использование флага `boolean` без синхронизации может быть **неэффективным**, потому что поток может **не увидеть изменение флага из-за кэширования**.
### 1️⃣ Использование `volatile` флага
- `volatile` гарантирует, что изменения флага **немедленно видны другим потокам**.
- Поток проверяет флаг в цикле и корректно завершает работу, когда флаг изменён.
```java
class Worker extends Thread {
    private volatile boolean running = true;

    public void run() {
        while (running) {
            // работа
        }
        System.out.println("Thread finished");
    }

    public void shutdown() {
        running = false; // видимость через volatile гарантирована
    }
}

// Использование:
Worker w = new Worker();
w.start();
w.shutdown(); // безопасное завершение
```
✅ Плюсы: простой и безопасный способ, учитывающий JMM.  
❌ Минусы: работает только для **циклической проверки флага**.
### 2️⃣ Использование `interrupt()` и проверки `Thread.interrupted()`
- Поток проверяет флаг прерывания и завершает работу.
```java
class Worker extends Thread {
    public void run() {
        while (!Thread.currentThread().isInterrupted()) {
            // работа
        }
        System.out.println("Thread finished");
    }
}

// Использование:
Worker w = new Worker();
w.start();
w.interrupt(); // безопасное завершение через прерывание
```
- **JMM гарантирует видимость** состояния прерывания другим потокам.
- Подходит для потоков, которые блокируются на `sleep()`, `wait()` или `join()`.
### 3️⃣ Синхронизация через `synchronized` блоки или `Lock`
- Поток проверяет флаг внутри синхронизированного блока, гарантируя **happens-before**.
```java
class Worker extends Thread {
    private boolean running = true;

    public void run() {
        while (true) {
            synchronized(this) {
                if (!running) break;
            }
            // работа
        }
        System.out.println("Thread finished");
    }

    public synchronized void shutdown() {
        running = false; // гарантированная видимость через synchronized
    }
}
```
✅ Гарантирует безопасную публикацию и завершение.
### 4️⃣ Использование `java.util.concurrent` классов
- **`AtomicBoolean`** — атомарная и видимая между потоками переменная:
```java
import java.util.concurrent.atomic.AtomicBoolean;

class Worker extends Thread {
    private AtomicBoolean running = new AtomicBoolean(true);

    public void run() {
        while (running.get()) {
            // работа
        }
        System.out.println("Thread finished");
    }

    public void shutdown() {
        running.set(false); // атомарная и безопасная публикация
    }
}
```
- **`ExecutorService.shutdown()`** — безопасно завершает все задачи, учитывая JMM.
### ✅ Итог
Для безопасного завершения потоков с учётом JMM:
1. Использовать `volatile` для флага завершения.
2. Или проверять `Thread.interrupted()`.
3. Или использовать `synchronized` / `Lock` для видимости.
4. Для атомарных флагов — `AtomicBoolean`.
5. Для пулов потоков — `ExecutorService.shutdown()`.