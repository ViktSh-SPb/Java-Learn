### Для чего используется аннотация @Autowired в Spring?

Аннотация `@Autowired` применяется для автоматического внедрения зависимостей (Dependency Injection) в компоненты Spring. Она позволяет контейнеру автоматически найти подходящий бин и внедрить его в поле, конструктор или сеттер класса, избавляя разработчика от необходимости явно создавать или управлять зависимостями.

Пример:

```java
@Component
public class ServiceA {
    @Autowired
    private Repository repository;
}
```

Здесь Spring автоматически внедрит подходящий бин `Repository` в поле `repository`.

### Какими способами можно определить нужный класс при внедрении интерфейса?

При внедрении интерфейсов, если есть несколько реализаций, можно указать конкретный класс или бина следующим образом:

- Использование `@Qualifier`: указывается имя бина, чтобы выбрать конкретную реализацию.

    ```java
    @Autowired
    @Qualifier("specificRepository")
    private Repository repository;
    ```

- Использование имени бина: если бин объявлен с именем, его можно указать через `@Qualifier`.
    
- Настройка при помощи конфигурационных классов: явно объявить нужную реализацию в конфигурации.

### Какие реализации IoC вы можете перечислить?

Основные реализации Inversion of Control (IoC) контейнера в Spring:

- BeanFactory: базовая реализация IoC контейнера, управляет жизненным циклом бинов.
- ApplicationContext: расширяет BeanFactory, добавляя поддержку событий, международализации и других функций. Наиболее часто используемый контейнер.
- AnnotationConfigApplicationContext: конфигурация через аннотации.
- GenericWebApplicationContext: для веб-приложений.
- WebApplicationContext: специализированный ApplicationContext для веб-приложений.

### Какие существуют области видимости (scopes) бинов в Spring и в чем их особенности?

Основные области видимости:

- singleton (по умолчанию): один экземпляр бина на весь контекст. Все обращения к нему возвращают один объект.
- prototype: каждый запрос создает новый экземпляр.
- request: один бин на HTTP-запрос (используется в веб-приложениях).
- session: один бин на сессию пользователя.
- application: один бин на весь жизненный цикл веб-приложения.
- websocket: один бин на WebSocket-сессию.

Особенности:

- singleton — самый распространенный режим, обеспечивает экономию ресурсов.
- prototype — полезен для состояния, которое не должно делиться между вызовами.
- request/session — для хранения данных, специфичных для пользователя или запроса.

### Перечислите этапы поднятия контекста в Spring

Этапы:

1. Создание конфигурации (через XML или аннотации).
2. Инициализация ApplicationContext (например, `AnnotationConfigApplicationContext`).
3. Регистрация конфигурационных классов или XML-файлов.
4. Обработка аннотаций и создание бинов согласно конфигурации.
5. Внедрение зависимостей (`@Autowired`, конструкторы).
6. Готовность контекста к использованию.

### Как можно создать бин в Spring без использования аннотаций?

Можно объявить бины через XML-конфигурацию:

```xml
<bean id="myBean" class="com.example.MyClass"/>
```

или через Java-конфигурацию с помощью `@Bean` внутри класса с аннотацией `@Configuration`:

```java
@Configuration
public class AppConfig {
    @Bean
    public MyClass myBean() {
        return new MyClass();
    }
}
```

### Как в Spring реализуется Dependency Injection и какие существуют его типы?

Dependency Injection (DI) реализуется через:

- Setter-инъекцию: внедрение через сеттеры (`setDependency()`).
- Конструкторскую инъекцию: внедрение через параметры конструктора.
- Поле-инъекцию (`@Autowired` на поле): автоматическая вставка зависимости прямо в поле.

Типы DI:

- Setter-based DI
- Constructor-based DI
- Field-based DI

Spring поддерживает все эти виды, что позволяет гибко управлять зависимостями.

### Что такое Spring Expression Language (SpEL) и как она используется в Spring Core?

SpEL — это язык выражений, встроенный в Spring, который позволяет динамически вычислять значения внутри конфигурации или аннотаций.

Использование:

- В аннотациях (`@Value("#{expression}")`)

    ```java
    @Value("#{2 + 2}")
    private int sum;
    ```

- В конфигурационных файлах для динамического определения значений.

Это удобно для вычислений, доступа к свойствам или вызова методов во время выполнения.

### Что такое циклические зависимости и как можно решить проблему с циклическими зависимостями?

Циклические зависимости возникают, когда два или более бина зависят друг от друга напрямую или косвенно:

```java
@Component
public class A {
    @Autowired
    private B b;
}

@Component
public class B {
    @Autowired
    private A a;
}
```

Решения:

- Использовать внедрение через `@Lazy`, чтобы отложить создание зависимостей:

    ```java
    @Autowired
    @Lazy
    private B b;
    ```

- Переформулировать архитектуру так, чтобы избавиться от циклов (например, использовать посредника или интерфейсы).
- В некоторых случаях можно использовать setter-инъекцию вместо конструктора или поля.