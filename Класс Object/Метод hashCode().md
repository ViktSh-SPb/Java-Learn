Метод **hashCode()** в Java - это метод класса **Object**, который возвращает целочисленных хеш-код объекта. Он используется в хеш-таблицах (например, **HashMap**, **HashSet**, **Hashtable**) для быстрого поиска и хранения объектов.
## Назначение метода:
- Возвращает числовое представление объекта (**хеш-код**), которое помогает эффективно хранить и искать объекты в коллекциях, основанных на хешировании.
- Если два объекта равны (**equals()** возвращает **true**), их **hashCode()** должен возвращать одинаковые значения (но обратное не всегда верно: разные объекты могут иметь одинаковый хеш-код - это называется коллизией).
## Синтаксис:
```java
public native int hashCode();
```
- Метод native, значит его реализация зависит от JVM (часто основана на адресе объекта в памяти, но не всегда)
- Возвращает int (32-битное целое число)
## Контракт между hashCode() и equals()
1. **Согласованность**. Если *a.equals(b) == true*, то и *a.hashCode() == b.hashCode()*
2. **Обратное не обязательно**. Если хеш-коды равны, объекты могут быть не равны (*коллизия*)
3. **Стабильность**. В течение одного выполнения программы *hashCode()* должен возвращать одно и то же значение, если объект не изменился (но между запусками программы хеш-код может отличаться)
⚠️ Нарушение контракта может привести к некорректной работе **HashMap**, **HashSet** и других структур.
## Примеры:
1. Стандартная реализация (из Object)
```java
Object obj = new Object();
System.out.println(obj.hashCode()) // Например, 356573597
```
2. Переопределение *hashCode()* в своем классе. Здесь *Objects.hash()* вычисляет хеш на основе полей *name* и *age*.
```java
class Person{
	String name;
	int age;
	@Override
	public int hashCode(){
		return Objects.hash(name, age) // Используем встроенный хеш-вычислитель
	}

	@Override
	public boolean equals(Object o){
		if (this == 0) return true;
		if (o == null || getClass() != o.getClass()) return false;
		Person person = (Person) o;
		return age == person.age && Objects.equals(name, person.name)
	}
}
```
3. Использование в HashMap
```java
Map<Person, String> map = new HashMap();
Person p1 = new Person("Alice", 30);
map.put(p1, "Developer");
System.out.println(map.get(p1)); // "Developer" - корректный поиск по хеш-коду
```
## Правила переопределения hashCode()
1. Используйте те же поля, что и в *equals()*
2. Желательно, чтобы хеш-код был как можно более уникальным (но коллизии допустимы)
3. Избегайте сложных вычислений (хеш-код должен вычисляться быстро)
4. Используйте *Objects.hash()* для удобного вычисления хеша по нескольким полям.
⚠️ Если *equals()* переопределен, а *hashCode()* - нет, то объекты с одинаковым содержимым могут попасть в разные корзины (*buckets*) в *HashMap*, и поиск по ключу даст *null*.
Пример ошибки:
```java
Person p1 = new Person ("Alice", 30);
Person p2 = new Person ("Alice", 30);

System.out.println(p1.equals(p2)); // true
System.out.println(p1.hashCode() == p2.hashCode()); // false, если hashCode() не переопределен
```