Коротко — **глобальных транзакций «ACID одновременно в БД + Kafka + RabbitMQ» над распределённой системой в надёжном, удобном виде нет** (т.е. двухфазный commit через всё подряд — либо очень дорогой и нежелательный, либо практически не используется).  
Вместо этого применяют архитектурные паттерны, которые дают **детерминированную согласованность** и устойчивость к сбоям: **Outbox (или Transactional Outbox)**, **Sagas (orchestrated / choreographed)**, использование **Kafka transactions / Kafka exactly-once** где это возможно и корректная работа с подтверждениями в RabbitMQ (publisher confirms). Ниже — практическое руководство и варианты реализации + примеры.
# Основные подходы (рекомендации по приоритету)
1. **Outbox + Relay (change-tail/CDC)** — самый надёжный, широко используемый.
2. **Sagas (хореография или оркестрация)** — для бизнес-транзакций, требующих компенсаций.
3. **Kafka transactions** — для атомарной записи в несколько Kafka-топиков/партиций (внутри Kafka).
4. **RabbitMQ publisher confirms** + idempotency — для доставки в очереди.
5. **2PC / XA** — технически возможны, но редко рекомендуются (сложно, медленно, ненадежно в масштабах микросервисов).
## 1. Outbox (Transactional Outbox) — наиболее практичный паттерн
Идея: записать событие в специальную таблицу `outbox` в той же транзакции, где изменяешь бизнес-данные. Затем отдельный процесс (relay/dispatcher) безопасно читает outbox и публикует события в Kafka / RabbitMQ, помечая их как отправленные.
Преимущества:
- атомарность (изменение данных + запись о событии) — в рамках одной БД-transaction;
- гарантии доставки при правильной реализации (at-least-once) + idempotency;
- не нужно распределённый commit.
Простой flow:
1. В одной транзакции:
    ```sql
    UPDATE orders SET status='PAID' WHERE id = 123;
    INSERT INTO outbox (aggregate_type, aggregate_id, event_type, payload, created_at)
    VALUES ('order', 123, 'OrderPaid', '{...}', now());
    COMMIT;
    ```
2. Relay-процесс периодически читает `outbox WHERE delivered = false ORDER BY id`, публикует в Kafka (transactional producer) или RabbitMQ (publisher confirms). После успешной публикации помечает строку как delivered (или удаляет).
Можно использовать CDC (Debezium) чтобы не писать relay: CDC читает WAL и публикует в Kafka прямо.
## 2. Sagas — для распределённых бизнес-транзакций
Когда одна бизнес-операция затрагивает несколько сервисов, используют Saga:
- **Хореография** — сервисы публикуют события и подписываются на события других сервисов; состояние протекает через события.
- **Оркестрация** — специальный «оркестратор» координирует шаги и выполняет компенсирующие действия при ошибке.
Пример:
1. Service A: резервация → публикует `ReservationCreated`.
2. Service B: получает событие → проводит оплату, публикует `PaymentCompleted` или `PaymentFailed`.
3. Если `PaymentFailed` — Service A выполняет компенсацию (отменяет бронь).
Важно: каждый шаг должен быть идемпотентным и иметь компенсатор.
## 3. Использование Kafka transactions (локально в Kafka)
Kafka поддерживает транзакции, которые позволяют атомарно записывать в несколько топиков/партиций и “commit” offsets вместе с producer transaction (чтобы consumer group не видел частичных результатов).
Пример Java (псевдо):
```java
Producer<String,String> producer = new KafkaProducer<>(props);
producer.initTransactions();

try {
  producer.beginTransaction();
  producer.send(new ProducerRecord<>("topicA", key, valueA));
  producer.send(new ProducerRecord<>("topicB", key, valueB));
  producer.commitTransaction();
} catch (Exception e) {
  producer.abortTransaction();
}
```
Это даёт атомарность **внутри Kafka**, но не покрывает БД или RabbitMQ.
## 4. Координация Kafka + RabbitMQ — практические схемы
### Вариант A — Outbox + Relay -> публиковать и в Kafka и в RabbitMQ
1. Записываешь изменения и события в `outbox` таблицу (в БД) в одной транзакции.
2. Relay читает outbox и:
    - может оборачивать публикацию в **Kafka transaction** для нескольких топиков,
    - и отдельно публикует в RabbitMQ с **publisher confirms**.
3. Relay помечает событие как отправленное только после успешной публикации в **обоих** системах. Если публикация в одной из них упала, relay ретраит (идемпотентность/дедупlication важна).
Псевдо-логика relay:
```text
for event in readOutbox():
  try:
    kafkaProducer.beginTransaction()
    kafkaProducer.send(topic, event)
    kafkaProducer.flush()
    // send to rabbit
    rabbitChannel.basicPublish(...); // use confirms
    waitForPublisherConfirm();
    kafkaProducer.commitTransaction()
    markOutboxSent(event.id)
  catch:
    kafkaProducer.abortTransaction()
    retryLater()
```
Нюанс: нужно аккуратно обрабатывать частичные успехи и ретраи; применять idempotency keys.
### Вариант B — Outbox -> Kafka -> Bridge -> RabbitMQ
- Relay публикует ТОЛЬКО в Kafka.
- Отдельный мост/consumer (или Kafka Connect) читает из Kafka и публикует в RabbitMQ.
- Это упрощает relay и использует Kafka как «источник истины».
## 5. RabbitMQ: транзакции vs confirms
- RabbitMQ поддерживает `txSelect()/txCommit()` (канальные транзакции), но они медленные и редко используются.
- Лучше использовать **publisher confirms** (asynchronous confirms) + обязательную пометку сообщений persistent, durable очереди. Это — практичный эквивалент подтверждения доставки.
Пример Java (amqp-client):
```java
channel.confirmSelect();
channel.basicPublish(exchange, routingKey, props, body);
boolean ok = channel.waitForConfirms(timeout); // true — подтверждение
```
Используй confirms + retry + DLQ.
## 6. Идемпотентность и дедупликация (ключевые практики)
- Всегда проектируй **идемпотентных** consumer-ов (по idempotency-key, event-id).
- В базе — хранить обработанные event IDs (inbox table) или использовать business keys.
- При ретраях и дублированной доставке это спасает от повторной обработки.
## 7. Обработка ошибок, retries и DLQ
- Для RabbitMQ: Dead-Letter Exchange / Dead-Letter Queue + TTL + retry queue pattern.
- Для Kafka: отдельный `*_failed` топик или retry topics; использовать экспоненциальные задержки или stream processing с DLQ.
## 8 . Пример end-to-end (рецепт для реализации)
1. DB transaction: обновил бизнес-объект + вставил строку в `outbox`.
2. Relay-сервис:
    - читает new outbox rows,
    - публикует в Kafka (можно начать kafka transaction если пишешь в несколько топиков),
    - публикует в RabbitMQ (publisher confirms),
    - при успехе помечает outbox как sent.
3. Продукты/consumers:
    - для Kafka — consumers читают и обновляют свои локальные состояния, используют idempotency и записывают processed IDs в inbox.
    - для RabbitMQ — consumers ack/nack и при ошибках используют DLQ.
## 9. Что НЕ рекомендуется
- Пытаться держать единый распределённый 2PC поверх БД + Kafka + RabbitMQ — сложность и плохая производительность.
- Полагаться на “exactly-once across systems” без тщательно продуманной архитектуры (обычно достигают eventual consistency).
## 10. Практические советы / чек-лист перед реализацией
- Реши, какие элементы являются «истиной» (source of truth) — обычно БД или Kafka.
- Используй Outbox или CDC (Debezium) для гарантированной публикации.
- Делаем idempotent consumers + хранение processed ids.
- Используй Kafka transactions только для гарантий внутри Kafka.
- Для RabbitMQ используем publisher confirms и durable queues.
- Реализуй DLQ / retry механизмы.
- Покрой все критические части тестами (failure injection, restarts).