В Java, начиная с версии **Java 8**, интерфейсы получили возможность содержать не только абстрактные методы, но и **реализованные** (дефолтные и статические), а с **Java 9** — ещё и **приватные** методы. Рассмотрим, зачем они нужны.  

---

## 1. **Дефолтные методы (`default`)**
### Для чего нужны?  
- **Обеспечивают обратную совместимость**  
  Можно добавлять новые методы в интерфейс, не ломая существующие реализации.  
- **Позволяют расширять интерфейсы без принудительной реализации**  
  Классы, реализующие интерфейс, могут использовать дефолтную реализацию или переопределить её.  

### Пример:
```java
interface Vehicle {
    void start();  // абстрактный метод
    
    default void honk() {  // дефолтный метод
        System.out.println("Beep beep!");
    }
}

class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("Car started");
    }
    // метод honk() не обязательно переопределять
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.start();  // "Car started"
        car.honk();   // "Beep beep!" (дефолтная реализация)
    }
}
```

---

## 2. **Статические методы (`static`)**
### Для чего нужны?  
- **Позволяют добавлять служебные методы прямо в интерфейс**  
  Раньше для этого использовали отдельные утилитные классы (например, `Collections`).  
- **Не требуют создания экземпляра интерфейса**  
  Вызываются через имя интерфейса (как `Math.sqrt()`).  

### Пример:
```java
interface MathUtils {
    static int square(int x) {
        return x * x;
    }
}

public class Main {
    public static void main(String[] args) {
        int result = MathUtils.square(5);  // 25
        System.out.println(result);
    }
}
```

---

## 3. **Приватные методы (`private`)**
### Для чего нужны?  
- **Уменьшают дублирование кода внутри интерфейса**  
  Можно вынести общую логику из `default` или `static` методов.  
- **Скрывают внутреннюю реализацию**  
  В отличие от `default`, приватные методы нельзя вызвать извне.  

### Пример (Java 9+):
```java
interface Logger {
    default void logInfo(String message) {
        log("INFO: " + message);
    }
    
    default void logError(String message) {
        log("ERROR: " + message);
    }
    
    private void log(String message) {  // приватный метод
        System.out.println("[LOG] " + message);
    }
}

class AppLogger implements Logger { }  // использует дефолтные методы

public class Main {
    public static void main(String[] args) {
        AppLogger logger = new AppLogger();
        logger.logInfo("App started");  // [LOG] INFO: App started
        logger.logError("Something went wrong!");  // [LOG] ERROR: Something went wrong!
    }
}
```

---

## Итоговая таблица

| Тип метода  | Когда появился | Можно вызвать у экземпляра? | Можно вызвать у интерфейса? | Можно переопределить? | Пример использования |
|-------------|----------------|-----------------------------|-----------------------------|-----------------------|-----------------------|
| **Абстрактный** | Java 1.0 | Да (если реализован) | Нет | Да | `void start();` |
| **Дефолтный (`default`)** | Java 8 | Да | Нет | Да (опционально) | `default void honk() { ... }` |
| **Статический (`static`)** | Java 8 | Нет | Да | Нет | `static int square(int x) { ... }` |
| **Приватный (`private`)** | Java 9 | Нет (только внутри интерфейса) | Нет | Нет | `private void log(String msg) { ... }` |

---

### Вывод:  
- **Дефолтные методы** — для обратной совместимости и расширения интерфейсов.  
- **Статические методы** — для утилитарных функций, связанных с интерфейсом.  
- **Приватные методы** — для избежания дублирования кода внутри интерфейса.  

Эти возможности делают интерфейсы более гибкими и удобными для проектирования API.