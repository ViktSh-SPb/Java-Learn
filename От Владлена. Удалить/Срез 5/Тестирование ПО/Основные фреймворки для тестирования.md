### Какие фреймворки используются для модульного тестирования в Java?

- JUnit — самый популярный фреймворк для модульного тестирования.
- TestNG — расширенный фреймворк, поддерживающий более сложные сценарии тестирования, параллельное выполнение и группировку тестов.
- Mockito — библиотека для создания мок-объектов, используемая вместе с JUnit или TestNG.
- AssertJ, Hamcrest — библиотеки для удобных и читаемых утверждений (assertions).

### Что такое JUnit и какие преимущества он предлагает для тестирования Java приложений?

JUnit — это фреймворк для написания и выполнения автоматических тестов на Java. Он помогает:

- Автоматизировать проверку корректности кода.
- Обеспечить быстрый обратный связь при разработке.
- Стандартизировать процесс тестирования.
- Поддерживать интеграцию с системами сборки (Maven, Gradle).
- Обеспечить структурированный подход к написанию тестов.

Преимущества:

- Простота использования.
- Поддержка аннотаций для определения методов теста, настройки окружения.
- Расширяемость через дополнительные библиотеки.

### Какие основные компоненты JUnit и как они работают вместе?

Основные компоненты:

- Тестовые классы: содержат методы с аннотациями `@Test`.
- Аннотации:
    - `@Test` — обозначает метод как тестовый.
    - `@BeforeEach`, `@AfterEach` — методы, выполняющиеся перед/после каждого теста.
    - `@BeforeAll`, `@AfterAll` — методы, выполняющиеся один раз перед/после всех тестов в классе.
    - `@DisplayName` — задает читаемое имя теста.
    - `@Disabled` — отключает выполнение теста.

Работа:

1. Создается класс с тестами.
2. Методы помечаются `@Test`.
3. Перед запуском вызываются методы с `@BeforeEach` или `@BeforeAll`.
4. Выполняются тестовые методы.
5. После каждого метода вызываются `@AfterEach`, а после всех — `@AfterAll`.

### Как работает процесс написания тестов с использованием JUnit?

Процесс:

1. Создаете класс с именем, например, `MyClassTest`.
2. Внутри класса пишете методы с аннотацией `@Test`.
3. Внутри методов вызываете код проверяемого класса и используете утверждения (`assertEquals`, `assertTrue` и др.).
4. Можно добавлять методы с настройками (`@BeforeEach`, `@AfterEach`) для подготовки окружения.

Запуск:

- Тесты запускаются через IDE (IntelliJ IDEA, Eclipse) или сборщики (Maven, Gradle).
- Результаты показывают, какие тесты прошли или не прошли.

### Опишите процесс настройки и запуска тестов с использованием JUnit и какие основные аннотации используются в этом процессе

Настройка:

1. Добавляете зависимость JUnit в проект (например, через Maven или Gradle).
2. Создаете класс с тестами.
3. Помечаете методы как `@Test`.

Запуск:

- В IDE: правой кнопкой по классу → Run as → JUnit Test.
- В командной строке: через Maven (`mvn test`) или Gradle (`gradle test`).

Основные аннотации:

- `@Test` — обозначение метода как теста.
- `@BeforeEach`, `@AfterEach` — подготовка/очистка перед/после каждого теста.
- `@BeforeAll`, `@AfterAll` — подготовка/очистка один раз перед/после всех тестов.

### Какие существуют виды тестирования ПО и для каких целей они используются?

Виды:

- Модульное (unit) тестирование: проверка отдельных компонентов или методов.
- Интеграционное: проверка взаимодействия нескольких компонентов вместе.
- Системное: проверка всей системы целиком в условиях, приближенных к реальным.
- Функциональное: проверка соответствия функциональных требований.
- Нефункциональное: производительность, безопасность, надежность и т.п.

Цели:

- Обнаружение ошибок на ранних этапах разработки.
- Обеспечение качества продукта.
- Поддержка рефакторинга без нарушения функциональности.

### Какие стратегии можно применить для тестирования микросервисов?

Стратегии:

- Контейнеризация: запуск микросервисов в Docker-контейнерах для изоляции среды.
- Мокинг зависимостей: использование Mockito или WireMock для имитации внешних сервисов.
- Параллельное выполнение: запуск нескольких микросервисов одновременно для интеграционных сценариев.
- Тестирование API: автоматические проверки REST API через Postman/Newman или RestAssured.
- End-to-end testing: автоматизированные сценарии пользовательского взаимодействия.

### Как реализовать параметризованные тесты в JUnit 5?

В JUnit 5 есть встроенная поддержка параметризованных тестов через аннотацию `@ParameterizedTest`. Можно использовать источники данных:

```java
@ParameterizedTest
@ValueSource(strings = {"apple", "banana"})
void testWithStrings(String fruit) {
    assertNotNull(fruit);
}
```

Также доступны источники данных из CSV, методов или аргументов из внешних источников.

### Какие особенности тестирования реактивных приложений и какие инструменты для этого используются?

Особенности:

- Асинхронность и неблокирующие операции требуют специальных подходов к проверке результатов (например, ожидание завершения).

Инструменты:

- Reactor Test: библиотека для реактивного программирования Reactor (Spring WebFlux).
    - Использует StepVerifier для проверки последовательностей реактивных потоков.

Пример:

```java
StepVerifier.create(reactiveMono)
    .expectNext(expectedValue)
    .verifyComplete();
```
