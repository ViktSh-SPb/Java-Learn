# 

Руководство по String pool в Java  

[Введение](https://topjava.ru/blog/rukovodstvo-po-string-pool-v-java#0)  
[1. Класс String](https://topjava.ru/blog/rukovodstvo-po-string-pool-v-java#1)  
[2. Интернирование строк](https://topjava.ru/blog/rukovodstvo-po-string-pool-v-java#2)  
[3. Создание строк с помощью конструктора](https://topjava.ru/blog/rukovodstvo-po-string-pool-v-java#3)  
[4. Ручное интернирование](https://topjava.ru/blog/rukovodstvo-po-string-pool-v-java#4)  
[5. Собственный пул строк](https://topjava.ru/blog/rukovodstvo-po-string-pool-v-java#5)  
[6. Сборщик мусора](https://topjava.ru/blog/rukovodstvo-po-string-pool-v-java#6)  
[7. Производительность и оптимизация](https://topjava.ru/blog/rukovodstvo-po-string-pool-v-java#7)  
[8. Пара слов о Java 9](https://topjava.ru/blog/rukovodstvo-po-string-pool-v-java#8)  
[9. Дедупликация](https://topjava.ru/blog/rukovodstvo-po-string-pool-v-java#9)  

Введение  

Класс _String_ (строка) является наиболее часто используемым классом в языке программирования Java. Исследования показывают, что до 25% объектов, находящихся в heap'е, являются объектами типа _String_. При этом половина из этих объектов имеют дубликаты. Существует ряд механизмов, направленных на оптимизацию памяти, занимаемую строками, которые мы рассмотрим в этой статье, а именно _интернирование_ в пул строк и _дедупликацию_.  

Для начала сделаем краткое введение в класс _String_.  

1. Класс String  

Класс _String_ отвечает за создание строк, состоящих из символов. А если быть точнее, заглянув в реализацию и посмотрев способ их хранения, то строки представляют собой массив символов (так было до Java 9):  

```
private final char value[];
```

Начиная с Java 9 строки хранятся как массив байт:  

```
private final byte[] value;
```

Причину смены используемого типа вы можете узнать из статьи «[Компактные строки в Java 9](https://topjava.ru/blog/compact-strings-java-9)».  

Строки в Java являются immutable, т. е. неизменяемыми.  

Создать объект класса _String_ можно двумя способами: при помощи строкового литерала и конструктора.  

Первый способ, а он является рекомендуемым, удобен и прост. Под строковым литералом понимается последовательность символов, заключенных в двойные кавычки:  

```
String stringLiteral = "TopJava";
```

Класс String имеет в своем распоряжении множество конструкторов, которые могут принимать на вход данные разного типа. Например, строковый литерал:  

```
String stringViaConstructor = new String("TopJava");
```

или массив символов:  

```
char[] chars = { 'T', 'o', 'p', 'J', 'a', 'v', 'a' };
String str = new String(chars);
```

Рассмотрим механизм создания и хранения строк более подробно.  

2. Интернирование строк  

Экземпляр класса _String_ хранится в памяти, именуемой _куча (heap)_, но есть некоторые нюансы. Если строка, созданная при помощи конструктора хранится непосредственно в куче, то строка, созданная как строковый литерал, уже хранится в специальном месте кучи — в так называемом _пуле строк (string pool)_. В нем сохраняются исключительно уникальные значения строковых литералов, а не все строки подряд. Процесс помещения строк в пул называется _интернирование (от англ. interning)_.  

Когда мы объявляем переменную типа _String_ и присваиваем ей строковый литерал, то JVM обращается в пул строк и ищет там такое же значение. Если пул содержит необходимое значение, то компилятор просто возвращает ссылку на соответствующий адрес строки без выделения дополнительной памяти. Если значение не найдено, то новая строка будет интернирована, а ссылка на нее возвращена и присвоена переменной.  

Пример:  

```
public class StringExampleOne {

    public static void main(String[] args) {
        String str1 = "TopJava";
        String str2 = "TopJava";

        System.out.println("Строка 1 равна строке 2? " + (str1 == str2));
    }
}
```

Результат выполнения программы:  

![](https://optim.tildacdn.com/tild6639-6161-4132-b634-303462623633/-/resize/760x/-/format/webp/carbon_27.png.webp)

Напомним, что знак «==» сравнивает ссылки на объекты, а не их значения. Результат выполнения программы подтверждает, что строки str1 и str2 ссылаются на одно и то же место в памяти в пуле строк.  

Иллюстративно это выглядит так:  

![](https://optim.tildacdn.com/tild6234-6639-4065-a563-303961643637/-/resize/760x/-/format/webp/Frame_197.jpg.webp)

В следующем примере попробуем «склеить» строковые литералы и посмотрим, влияет ли конкатенация на результат:  

```
public class StringExampleTwo {

    public static void main(String[] args) {
        String str1 = "TopJava";
        String str2 = "Top" + "Java";

        System.out.println("Строка 1 равна строке 2? " + (str1 == str2));
    }
}
```

Результат выполнения программы:  

![](https://optim.tildacdn.com/tild6361-3836-4338-a366-383337323966/-/resize/760x/-/format/webp/carbon_28.png.webp)

В строке «Top» + «Java» создаются два строковых объекта со значениями _«Top»_ и _«Java»_, которые помещаются в пул. «Склеенные» строки образуют еще одну строку со значением «TopJava», ссылка на которую берется из пула строк (а не создается заново), т.к. она была интернирована в него ранее.  

Значения всех строковых литералов из данного примера известно на этапе компиляции.  

Иллюстративно итоговый результат выглядит так:  

![](https://optim.tildacdn.com/tild3731-3831-4761-a165-616437383964/-/resize/760x/-/format/webp/Frame_215.jpg.webp)

А теперь давайте рассмотрим еще один пример, который выдаст неожиданный результат:  

```
public class StringExampleThree {

    public static void main(String[] args) {
        String str1 = "TopJava";
        String str2 = "Java";
        String str3 = "Top" + str2;

        System.out.println("Строка 1 равна строке 3? " + (str1 == str3));
    }
}
```

Результат выполнения программы:  

![](https://optim.tildacdn.com/tild6531-3136-4866-b334-383731333836/-/resize/760x/-/format/webp/carbon_29.png.webp)

Схематично это выглядит примерно так:  

![](https://optim.tildacdn.com/tild3734-3833-4834-b733-653938633934/-/resize/760x/-/format/webp/Frame_201_1.jpg.webp)

Причиной получения false является то, что интернирование происходит не во время работы приложения (runtime), а во время компиляции. А т.к. значение строки _str3_ вычисляется во время выполнения приложения, то на этапе компиляции оно не известно и потому, не добавляется в пул строк.  

3. Создание строк с помощью конструктора  

Теперь давайте рассмотрим детальнее процесс создания объекта _String_ при помощи конструктора.  

Когда мы создаем экземпляр класса _String_ с помощью оператора _new_, компилятор размещает строки в куче. При этом каждая строка, созданная таким способом, помещается в кучу (и имеет свою ссылку), даже если такое же значение уже есть в куче или в пуле строк.

Создадим строки через интернирование и с помощью конструктора, а затем сравним их ссылки:

```
public class StringExampleFour {

    public static void main(String[] args) {
        String str1 = "TopJava";
        String str2 = "TopJava";
        String str3 = new String("TopJava");
        String str4 = new String("TopJava");

        System.out.println("Строка 1 равна строке 2? " + (str1 == str2));
        System.out.println("Строка 2 равна строке 3? " + (str2 == str3));
        System.out.println("Строка 3 равна строке 4? " + (str3 == str4));
    }
}
```

Результат выполнения программы:  

![](https://optim.tildacdn.com/tild3833-6230-4339-b031-386239326164/-/resize/760x/-/format/webp/carbon_30.png.webp)

Иллюстративно это выглядит так:  

![](https://optim.tildacdn.com/tild3231-3735-4564-b235-333766393963/-/resize/760x/-/format/webp/Frame_214.png.webp)

Таким образом, создав четыре одинаковых строки, в памяти зафиксируются только три объекта. Согласитесь, что это нерационально.  

4. Ручное интернирование  

В _Java_ существует возможность вручную выполнить интернирование строки в пул путем вызова метода _intern()_ у объекта типа _String_. Видоизменим приведенный ранее пример, добавив метод _intern()_ к созданным при помощи конструктора строкам:  

```
public class StringExampleFive {

    public static void main(String[] args) {
        String str1 = "TopJava";
        String str2 = "TopJava";
        String str3 = (new String("TopJava")).intern();
        String str4 = (new String("TopJava")).intern();

        System.out.println("Строка 1 равна строке 2? " + (str1 == str2));
        System.out.println("Строка 2 равна строке 3? " + (str2 == str3));
        System.out.println("Строка 3 равна строке 4? " + (str3 == str4));
    }
}
```

Результат выполнения программы:  

![](https://optim.tildacdn.com/tild6632-6430-4530-b762-313566663663/-/resize/760x/-/format/webp/carbon_31.png.webp)

Иллюстративно это выглядит так:  

![](https://optim.tildacdn.com/tild3532-6331-4566-b735-373630383863/-/resize/760x/-/format/webp/Frame_202.jpg.webp)

Рассмотрим еще один интересный пример:  

```
public class StringExampleSix {

    public static void main(String[] args) {
        String str1 = "interned TopJava";
        String str2 = "TopJava";
        String str3 = ("interned " + str2).intern();

        System.out.println("Строка 1 равна строке 3? " + (str1 == str3));
    }
}
```

Результат выполнения программы:  

![](https://optim.tildacdn.com/tild3562-3439-4464-a433-376539346334/-/resize/760x/-/format/webp/carbon_32.png.webp)

Соответственно, иллюстративно это выглядит так:  

![](https://optim.tildacdn.com/tild3038-3035-4539-b132-303030616535/-/resize/760x/-/format/webp/Frame_203.jpg.webp)

Поясним результат. Строки _str1_ и _str2_ добавлены в пул строк на этапе компиляции. Во время выполнения программы происходит конкатенация строки «_interned»_ со значением строки _str2_, с последующим интернированием получившейся строки в пул строк (благодаря методу _intern()_). Но, так как пул строк уже содержит строку «_interned TopJava_», объекту _String str3_ будет присвоена ссылка на строку в пуле строк и, соответственно, выражение равенства ссылок «==» будет истинным.  

Принимая во внимание всё вышесказанное, вы можете спросить: «Почему бы все строки сразу после их создания не добавлять в пул строк? Ведь это приведет к экономии памяти…». Да, среди достаточно большого количества программистов такое заблуждение присутствует. Именно заблуждение, поскольку не все учитывают дополнительные затраты виртуальной машины на процесс интернирования, а также падение производительности, в целом. Тесты и наглядное подтверждение этого приводятся в видео докладе [Алексея Шипилёва — «Катехизис java.lang.String»](https://www.youtube.com/watch?v=SZFe3m1DV1A). Финализируя доклад Алексея можно сказать, что интернирование (в виде применения метода intern ()) рекомендуется вообще не использовать. Вместо интернирования необходимо использовать дедупликацию (рассматривается далее).  

[![](https://optim.tildacdn.com/tild6533-3136-4233-b938-653066373537/-/resize/760x/-/format/webp/Group_41.png.webp)](https://topjava.ru/startjava)

5. Собственный пул строк  

Что же тогда делать, если мы создаем много объектов класса _String_? Нам ничего не мешает написать свой собственный пул строк, доступ к которому может быть быстрее, чем к пулу виртуальной машины. После того, как он справится со своей работой, его можно легко уничтожить.  

Рассмотрим пример (источник: доклад [Алексея Шипилёва — «Катехизис java.lang.String»](https://www.youtube.com/watch?v=SZFe3m1DV1A), код доработан):  

```
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class CHMInterner <T> {
    private final Map<T, T> map;

    public CHMInterner() {
        map = new ConcurrentHashMap<>();
    }

    public T intern(T t) {
        T exist = map.putIfAbsent(t, t);
        return (exist == null) ? t : exist;
    }

    public int internSize() {
        return map.size();
    }
}
```

```
public class Main {
    public static void main(String[] args) {
        CHMInterner chmInterner = new CHMInterner();

        chmInterner.intern("TopJava_1");
        chmInterner.intern("TopJava_2");
        chmInterner.intern("TopJava_2");
        chmInterner.intern("TopJava_3");
        chmInterner.intern("TopJava_3");
        chmInterner.intern("TopJava_3");
        chmInterner.intern("TopJava_4");
        chmInterner.intern("TopJava_4");
        chmInterner.intern("TopJava_4");
        chmInterner.intern("TopJava_4");

        System.out.println("Размер пула строк равен: " + chmInterner.internSize());
    }
}
```

Результат выполнения программы:  

![](https://optim.tildacdn.com/tild3636-3566-4337-a538-666235643334/-/resize/760x/-/format/webp/carbon_34.png.webp)

Таким образом, на основе _ConcurrentHashMap_ был создан пул строк, в который мы пытались добавить 10 повторяющихся строк. В итоге были добавлены только 4 уникальных строки.  

6. Сборщик мусора  

До Java версии 7 виртуальная машина размещала пул строк в области памяти под названием [PermGen](https://topjava.ru/blog/permgen-and-metaspace), которая имеет фиксированный размер и не может быть расширена во время выполнения приложения. Также следует отметить, что на эту область памяти не распространяется действие сборщика мусора.  

Риск интернирования строк в область PermGen (вместо кучи) заключается в том, что мы можем получить от JVM ошибку OutOfMemoryError, если будем интернировать слишком много строк (PermGen имеет фиксированный размер).  

Учтите, что однажды интернированную строку в версии Java ниже 7й нельзя деинтернировать: она будет занимать память программы даже тогда, когда перестанет быть нужна. Из этого следует, что чрезмерное интернирование строк может оказать негативный эффект, связанный с утечками памяти!  

Начиная с Java 7, пул строк размещается в куче, на которую распространяется процесс сборки мусора. Преимуществом данного подхода является снижение вероятности появления ошибки OutOfMemoryError, так как строки, на которые не будет ссылаться ни одна переменная в выполняемой программе, будут удалены сборщиком мусора из пула, что приведет к освобождению памяти.  

7. Производительность и оптимизация  

В _Java 6_ единственной оптимизацией, которую мы могли сделать — это увеличить размер PermGen во время запуска программы, используя опцию JVM — _MaxPermSize_:  

```
-XX:MaxPermSize=1G
```

В _Java 7_ разработчикам предоставили более гибкую возможность настройки (увеличение/уменьшение) размера пула строк. Существуют две возможности посмотреть размер пула:  

```
-XX:+PrintStringTableStatistics
и
-XX:+PrintFlagsFinal
```

В Java 6 и Java 7 _(до Java7u40)_ значение по умолчанию для параметра _-XX:StringTableSize_ равняется 1009. С _Java7u40_ размер увеличен до 60 013 (такое же значение используется и в _Java 8_). В _Java_ 11, 13 и 15 это значение уже составляет 65 536.  

Рассмотрим при помощи команды _-XX:+PrintStringTableStatistics_ размер пула строк и другие данные:  

```
SymbolTable statistics:
Number of buckets   	   : 	32768 = 262144 bytes, each 8
Number of entries   	   :    517 =   8272 bytes, each 16
Number of literals  	   :    517 =  19712 bytes, avg  38,000
Total footprint     	   :        = 290128 bytes
Average bucket size 	   :	0,016
Variance of bucket size    :  0,016
Std. dev. of bucket size   :  0,125
Maximum bucket size        :      2
StringTable statistics:
Number of buckets   	   : 	65536 = 524288 bytes, each 8
Number of entries   	   :     68 =   1088 bytes, each 16
Number of literals  	   :     68 =   4648 bytes, avg  68,000
Total footprint     	   :        = 530024 bytes
Average bucket size 	   :  0,001
Variance of bucket size    :  0,001
Std. dev. of bucket size   :  0,032
Maximum bucket size        :      1
```

Если мы хотим увеличить размер пула, то для этого необходимо воспользоваться опцией _StringTableSize_:  

```
-XX:StringTableSize=4901
```

Следует обратить внимание на то, что увеличение размера пула приведет к тому, что будет задействован больший объем памяти, но при этом сократится время, необходимое для добавления строки непосредственно в пул.  

8. Пара слов о Java 9  

До _Java 8_ строка внутренне представлялась, как массив символов _char[]_ в кодировке _UTF-16_, каждый из которых занимал по два байта в памяти.  

В _Java 9_ было внедрено новое представление для типа _String_, получившее название [компактные строки](https://topjava.ru/blog/compact-strings-java-9) (_Compact Strings_). Благодаря новому формату хранения строк (в зависимости от контента) делается выбор между массивом символов _char[]_ и массивом байт _byte[]_.  

Поскольку новый способ хранения объектов типа String использует кодировку _UTF-16_ лишь в том случае, когда в этом есть необходимость, объем памяти, занимаемый пулом строк в куче, будет значительно ниже, что в, свою очередь, уменьшит издержки работы сборщика мусора.  

Ключевые моменты:  

- Строки в Java представляют собой константы, которые не могут быть изменены  
    
- Создать объект класса _String_ можно двумя способами: при помощи строкового литерала и конструктора  
    
- Строковый литерал сохраняется в пул строк, если до этого он там отсутствовал  
    
- Строка, созданная при помощи конструктора, сохраняется в heap, а не в пул строк  
    
- Java 6: Пул строк хранится в памяти фиксированного размера, именуемого PermGen.  
    
- Java 7, 8: Пул строк хранится в heap и, соответственно, для пула строк можно использовать всю память приложения  
    
- При помощи параметра _-XX:StringTableSize=N_, где _N_ — размер _HashMap_, можно изменить размер пула строк. Его размер является фиксированным, поскольку он реализован, как _HashMap_ со списками в корзинах  
    
- Инженеры по оптимизации _Java_ компании Oracle настоятельно не рекомендуют самостоятельно интернировать строки, поскольку это приводит к замедлению работы приложения. Их рекомендация — дедупликация.  
    

9. Дедупликация  

Как мы написали в самом начале, класс _String_ представляет собой массив байт:  

```
private final byte[] value;
```

А т.к. созданный экземпляр класса String нельзя модифицировать, т. е. содержимое массива _value[]_ нельзя изменить_,_ то его значение может быть безопасно использовано одновременно несколькими объектами _String._  

[Дедупликация](https://openjdk.java.net/jeps/192) представляет собой не что иное, как переприсваивание виртуальной машиной адресов поля _value_. Т. е. мы выполняем дедупликацию не объектов _String,_ а массивов их байт. Поля _value_ нескольких объектов типа String с одинаковым значением текста изначально ссылаются на разные участки памяти (разные массивы байт), а после дедупликации будут ссылаться на один и тот же участок памяти, содержащий массив байт.  

Кроме того, у нас все еще остаются накладные расходы в виде заголовка объекта, полей и др. Такие накладные расходы зависят от платформы/конфигурации и варьируются в пределах от 24 до 32 байт. Однако, для средней длины объекта _String_ в 45 символов (90 байт + заголовок массива), это все еще значительные цифры. Принимая во внимание вышеперечисленное, актуальный выигрыш в экономии памяти может быть около 10%.  

9.1. Как работает дедупликация  

Во время сборки мусора GC проверяет живые (имеющие рабочие ссылки) объекты в куче на возможность провести их дедупликацию. Ссылки на подходящие объекты вставляются в очередь для последующей обработки. Далее происходит попытка дедупликации каждого объекта _String_ из очереди, а затем удаление из нее ссылок на объекты, на которые они ссылаются. Также для отслеживания всех уникальных массивов байт, используемых объектами _String,_ используется хеш-таблица. При дедупликации в этой хеш-таблице выполняется поиск идентичных массивов байт (символов).  

При положительном результате значение поля _value_ объекта _String_ переприсваивается так, чтобы указывать на этот существующий массив байт. Соответственно, предыдущий массив байт _value_ становится ненужным — на него ничего не ссылается и впоследствии он попадает под сборку мусора.  

При отрицательном результате, массив байт, соответствующий _value,_ вставляется в хеш-таблицу, чтобы впоследствии быть использованным совместно с новым объектом _String_ в какой-то другой момент в будущем.  

Давайте поэкспериментируем, запустив следующую программу:  

```
import java.lang.reflect.Field;

public class DeduplicationDemo {

    public static void main(String[] args) throws InterruptedException, NoSuchFieldException, IllegalAccessException {
        char[] chars = {'T', 'o', 'p', 'J', 'a', 'v', 'a'};
        String[] strings = {new String(chars), new String(chars)};
        Field value = String.class.getDeclaredField("value");
        value.setAccessible(true);

        System.out.println("Хеш первого объекта: " + value.get(strings[0]));
        System.out.println("Хеш второго объекта: " + value.get(strings[1]));

        System.gc();
        System.out.println("Запустили сборщик мусора");
        Thread.sleep(100);

        System.out.println("Хеш первого объекта: " + value.get(strings[0]));
        System.out.println("Хеш второго объекта: " + value.get(strings[1]));
    }
}
```

Результат выполнения программы:  

![](https://optim.tildacdn.com/tild3934-3338-4931-a536-393536633765/-/resize/760x/-/format/webp/carbon_37.png.webp)

Как видим, дедупликация не сработала. Для ее активации необходимо в параметрах виртуальной машины указать -_XX:+UseStringDeduplication_, а также активировать сборщик мусора G1 (если он не используется по умолчанию), указав также -_XX:+UseG1GC_.  

В этом случае имеем правильный результат выполнения программы:  

![](https://optim.tildacdn.com/tild6465-6536-4336-b434-383836346334/-/resize/760x/-/format/webp/carbon_38.png.webp)

Результат говорит о следующем: создав два объекта с помощью _new,_ мы получили два разных объекта с разными идентификационными хешами для массивов байт. Запустив сборщик мусора и подождав некоторое время (дедупликация не происходит мгновенно), мы видим, что хеши для двух объектов стали одинаковы (ссылаются на один и тот же массив).  

Иллюстративно это выглядит так:  

![](https://optim.tildacdn.com/tild6439-3131-4434-b163-346638633238/-/resize/760x/-/format/webp/pasted_image_0_3.png.webp)

Видоизменим немного код, добавив в массив строковый литерал:  

```
import java.lang.reflect.Field;

public class DeduplicationDemo {

    public static void main(String[] args) throws InterruptedException, NoSuchFieldException, IllegalAccessException {
        char[] chars = {'T', 'o', 'p', 'J', 'a', 'v', 'a'};
        String[] strings = {new String(chars), new String(chars), "TopJava"};
        Field value = String.class.getDeclaredField("value");
        value.setAccessible(true);

        System.out.println("Хеш первого объекта: " + value.get(strings[0]));
        System.out.println("Хеш второго объекта: " + value.get(strings[1]));
        System.out.println("Хеш третьего объекта: " + value.get(strings[2]));

        System.gc();
        System.out.println("Запустили сборщик мусора");
        Thread.sleep(100);

        System.out.println("Хеш первого объекта: " + value.get(strings[0]));
        System.out.println("Хеш второго объекта: " + value.get(strings[1]));
        System.out.println("Хеш третьего объекта: " + value.get(strings[2]));
    }
}
```

Результат выполнения программы:  

![](https://optim.tildacdn.com/tild6231-3864-4038-b632-366166356335/-/resize/760x/-/format/webp/carbon_42.png.webp)

Иллюстративно это выглядит так:  

![](https://optim.tildacdn.com/tild3262-3430-4637-b164-356134313062/-/resize/760x/-/format/webp/pasted_image_0_4.png.webp)

Создав строковый литерал _str3_, мы, тем самым, строку «_TopJava_» добавили в пул строк. Во время дедупликации виртуальная машина увидев, что в пуле строк уже содержится такой массив байт, изменила адрес массива _byte[]_ для созданных через конструктор строковых объектов на адрес массива _byte[]_ строкового литерала, находящегося в пуле строк.  

Чтобы убедиться, что этот результат был получен благодаря дедупликации, попробуйте отключить функционал дедупликации строк в виртуальной машине.  

Ключевые моменты:  

- Дедупликация строк доступна с _Java 8 Update 20_
- Она активируется параметром для виртуальной машины: _-XX:+UseStringDeduplication_
- Дедупликация строк работает только со сборщиком мусора _G1_. Для его активации в _Java 8_ необходимо указать параметр для виртуальной машины _-XX:+UseG1GC_. Начиная с _Java 9_, G1 является сборщиком мусора по умолчанию
- Опыты показывают, что применение дедупликации строк сокращает расходы кучи на примерно 10%, что, в принципе, неплохо, учитывая, что нам не нужно вносить изменение в код
- Дедупликация строк работает в фоновом режиме без приостановления работы приложения
- В отличие от пула строк, который применим только для строк, интернированных командой _intern()_, или строковых литералов, но не применим для строк, созданных динамически во время жизни приложения, дедупликация строк применима для строк, созданных всеми этими способами

**Автор:** Малянов Игорь  
**Технический редактор:** Чимаев Максим  

Оцените статью, если она вам понравилась!