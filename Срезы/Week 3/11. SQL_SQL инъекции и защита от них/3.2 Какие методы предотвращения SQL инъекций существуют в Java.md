# 1. PreparedStatement — базовый и обязательный метод
Используйте `PreparedStatement` и передавайте все **значения** как параметры (никогда — конкатенацию).
```java
String sql = "SELECT * FROM users WHERE email = ? AND status = ?";
try (PreparedStatement ps = conn.prepareStatement(sql)) {
    ps.setString(1, email);
    ps.setString(2, status);
    try (ResultSet rs = ps.executeQuery()) { ... }
}
```
Преимущества: СУБД/драйвер трактуют параметры как данные — не как SQL.
# 2. CallableStatement — параметры для хранимых процедур
Если используете хранимые процедуры, вызывайте их через `CallableStatement` и тоже параметризуйте вход:
```java
CallableStatement cs = conn.prepareCall("{call update_user(?, ?)}");
cs.setLong(1, userId);
cs.setString(2, newName);
cs.execute();
```
(Внутри процедуры избегайте динамического SQL без параметров.)
# 3. Использование ORM и безопасных API (Hibernate, JPA, Spring Data)
ORM обычно делают параметризацию за вас — используйте named parameters / Criteria API:
JPA (JPQL) пример:
```java
TypedQuery<User> q = em.createQuery(
  "SELECT u FROM User u WHERE u.email = :email", User.class);
q.setParameter("email", email);
```
Criteria API (динамика без конкатенации SQL) — безопасный способ строить запросы программно.
⚠️ При использовании `createNativeQuery` или `entityManager.createNativeQuery(...)` — тоже всегда передавайте параметры, а не конкатенируйте.
# 4. Spring JDBC — JdbcTemplate и NamedParameterJdbcTemplate
`JdbcTemplate` с `PreparedStatement`:
```java
jdbcTemplate.query("SELECT * FROM users WHERE id = ?",
    new Object[]{id}, rowMapper);
```
`NamedParameterJdbcTemplate` удобно для динамики и IN-списков:
```java
String sql = "SELECT * FROM products WHERE id IN (:ids)";
MapSqlParameterSource params = new MapSqlParameterSource();
params.addValue("ids", Arrays.asList(1,2,3));
namedJdbc.query(sql, params, rowMapper);
```
# 5. Безопасная работа с IN-списками
Не конкатенируйте `IN (1,2,3)` строкой. В JDBC используйте:
- динамическое создание placeholder-ов (`?, ?, ?`) + `PreparedStatement.setXXX`,
- или `SET`/`ARRAY` для СУБД, которые поддерживают массивы (`setArray`),
- или `NamedParameterJdbcTemplate` / `Hibernate.setParameterList()`.
Пример динамических placeholder-ов:
```java
List<Integer> ids = ...
String placeholders = ids.stream().map(i -> "?").collect(joining(","));
String sql = "SELECT * FROM t WHERE id IN (" + placeholders + ")";
PreparedStatement ps = conn.prepareStatement(sql);
for (int i=0;i<ids.size();i++) ps.setInt(i+1, ids.get(i));
```
# 6. Whitelist (белые списки) для динамических идентификаторов
Имена таблиц, столбцов,方向 сортировки нельзя параметризовать — **проверяйте по белому списку**:
```java
Map<String,String> allowed = Map.of("name","name","date","created_at");
String order = allowed.getOrDefault(userParam, "created_at");
String sql = "SELECT * FROM t ORDER BY " + order;
```
Никакой прямой вставки `userParam`!
# 7. Экранирование LIKE-шаблонов и спецсимволов
Для `LIKE` параметры всё равно ставьте через PreparedStatement, но экранируйте `%/_` в пользовательском вводе и используйте ESCAPE, если нужно.
```java
ps.setString(1, escapeLike(userInput) + "%");
```
# 8. Ограничение прав доступа (principle of least privilege)
Приложение должно подключаться под пользователем с **минимальными** правами (SELECT/INSERT/UPDATE по нужным таблицам). Ни в коем случае — не root/superuser.
# 9. Отключение возможности выполнения нескольких SQL-операторов за один запрос
Некоторые драйверы/СУБД позволяют выполнять `; DROP TABLE ...` в одном запросе — отключите `allowMultiQueries` (MySQL) и подобные опции, если не нужны.
# 10. WAF, логирование, мониторинг и тестирование
- WAF (Web Application Firewall) может блокировать типичные SQLi-паттерны.
- Логи и SIEM: мониторьте аномальные длинные запросы, частые `UNION`, `--`, `/*`.
- Регулярные SAST/DAST и pentests.
# 11. Безопасная работа с динамическими SQL-шаблонами (шаблоны + whitelist)
Если у вас множество заранее известных вариантов запросов — храните их как шаблоны и выбирайте по ключу, а не формируйте SQL динамически из произвольных строк.
# 12. Регулярные обновления и патчи
Обновляйте драйверы JDBC, СУБД и фреймворки — уязвимости закрываются в апдейтах.
# 13. Примеры «что нельзя делать»
Плохо:
```java
String sql = "SELECT * FROM users WHERE name = '" + userInput + "'";
Statement st = conn.createStatement();
st.executeQuery(sql);  // Уязвимо!
```
Плохо (raw native query в JPA):
```java
em.createNativeQuery("SELECT * FROM t WHERE col='" + value + "'").getResultList();
```
## Короткий чеклист для команды (рекомендуется всегда применять)
- Все значения в SQL — параметры (`PreparedStatement`, `setParameter`).
- Динамические идентификаторы (таблицы/столбцы/ORDER BY) — только через whitelist.
- Использовать ORM/Criteria API или JdbcTemplate с параметрами.
- Ограничить права DB-пользователя.
- Отключить мультизапросы, если не нужны.
- Логи, мониторинг, SAST/DAST и регулярные pentest'ы.
- Обновления драйверов и СУБД.