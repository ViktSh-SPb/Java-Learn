В контексте **Java**, **Java Memory Model (JMM)** — это **спецификация, которая определяет, как потоки взаимодействуют через память** и какие гарантии видимости и упорядочения операций предоставляет JVM. Проще говоря, JMM отвечает на вопросы:
- Когда изменения одного потока видны другим потокам?
- Как работают `volatile`, `synchronized` и атомарные операции?
- Какие оптимизации компилятор и CPU могут делать без нарушения корректности многопоточного кода?
### 1️⃣ Основные понятия JMM
**1. Main Memory (главная память) и Working Memory (локальная память потока)**
- **Main Memory** — это фактически **heap** в JVM. Все объекты хранятся здесь.
- **Working Memory** — это **кэш потоков** (CPU registers, кэш). Каждый поток может временно хранить копии переменных из main memory.
> JMM говорит: поток может видеть **не актуальные значения** переменных из main memory, если не синхронизирован.

**2. Atomicity, Visibility и Ordering**
- **Atomicity (атомарность)** – операция выполняется полностью или не выполняется вовсе. Например, чтение/запись `int` атомарны, а `long`/`double` без `volatile` могут не быть атомарными на 32-битных системах.
- **Visibility (видимость)** – изменения переменной одним потоком могут быть **не сразу видны другим**. `volatile` гарантирует, что изменения будут видны всем потокам.
- **Ordering (упорядочение)** – компилятор и CPU могут менять порядок инструкций для оптимизации, но JMM задаёт **правила «happens-before»**, которые определяют корректное поведение многопоточного кода.
### 2️⃣ Ключевые правила `happens-before`
`happens-before` — отношение между действиями потоков. Если `A happens-before B`, то:
1. Все эффекты A **видны** B.
2. A выполняется до B.
**Примеры:*

|Ситуация|Что гарантируется|
|---|---|
|`synchronized(lock) { ... }`|Вход в блок синхронизации **happens-before** выход из него другим потоком на том же lock|
|`volatile var = value;`|Запись **happens-before** чтения того же volatile в другом потоке|
|Thread.start()|Все изменения перед вызовом start() видны потоку после запуска|
|Thread.join()|Все изменения в потоке завершившемся join() видны вызывающему потоку|
### 3️⃣ Почему это важно
Без JMM код может работать нестабильно:
```java
class Flag {
    boolean done = false;
}

Flag flag = new Flag();

Thread t1 = new Thread(() -> {
    flag.done = true;
});

Thread t2 = new Thread(() -> {
    while (!flag.done) {
        // может зациклиться бесконечно
    }
});
```
- Без `volatile` или синхронизации `t2` может **никогда не увидеть** `done = true`.
- С `volatile boolean done` проблема решается: запись одного потока гарантированно видна другому.