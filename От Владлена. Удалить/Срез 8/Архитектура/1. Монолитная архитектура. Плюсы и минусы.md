### Что такое монолитная архитектура?

Монолитная архитектура — это подход к разработке программных систем, при котором все компоненты приложения объединены в единую, тесно связанную и взаимозависимую структуру. В таком случае все функции, модули и сервисы реализованы внутри одного приложения или исполняемого файла, и взаимодействие между ними происходит внутри одного процесса.

### Какие основные преимущества монолитной архитектуры?

- **Простота разработки и развертывания:** все компоненты находятся в одном проекте, что облегчает начальную разработку и запуск.  
- **Высокая производительность:** внутренние вызовы между компонентами происходят быстрее, чем межсервисное взаимодействие по сети.  
- **Простота тестирования:** можно тестировать систему целиком без необходимости настройки сложных инфраструктурных решений.  
- **Меньшие требования к инфраструктуре:** не нужно управлять множеством сервисов или контейнеров.

### В каких случаях предпочтительно использовать монолитную архитектуру?

- Для небольших или средних по масштабу приложений, где сложность системы невысока.  
- Когда важна быстрая разработка и запуск продукта без необходимости сложной инфраструктуры.  
- В случаях, когда требования к масштабированию и обновлению системы не очень высоки.  
- Для прототипирования или MVP (минимально жизнеспособного продукта), чтобы быстро проверить идеи.

### Какие недостатки монолитной архитектуры могут повлиять на процесс разработки?

- **Сложность масштабирования и обновления:** при росте системы изменение одного компонента может требовать пересборки и перезапуска всего приложения.  
- **Трудности в поддержке и расширении:** со временем монолит становится сложнее модифицировать, так как все части tightly coupled.  
- **Высокая связность компонентов:** изменение в одном модуле может привести к необходимости изменений в других, что увеличивает риск ошибок.  
- **Долгое время сборки и тестирования:** при увеличении размера системы сборка и тестирование могут занимать значительное время.  
- **Ограниченная гибкость команд разработки:** разные команды работают над одним проектом, что может привести к конфликтам и сложности координации.

### Как монолитная архитектура влияет на масштабирование приложения?

- **Вертикальное масштабирование:** обычно возможно только за счет увеличения ресурсов (CPU, RAM) для всего приложения.  
- **Горизонтальное масштабирование:** усложнено, так как необходимо запускать несколько экземпляров всего монолита, что может быть неэффективно и дорого.  
- **Ограниченная гибкость:** масштабировать отдельные части системы отдельно сложно или невозможно без значительных изменений в архитектуре.  
- В результате, при росте нагрузки система может стать узким местом из-за необходимости масштабировать всё приложение целиком.

### Какие стратегии можно использовать для разделения монолитной архитектуры на более мелкие компоненты?

- **Микросервисы:** разбить систему на независимые сервисы с четкими границами ответственности, которые взаимодействуют через API или сообщения.  
- **Модульное разделение:** выделить внутри монолита отдельные модули или слои с четкими интерфейсами, чтобы упростить их развитие и поддержку.  
- **Постепенный рефакторинг:** поэтапно выделять части системы в отдельные сервисы или модули, начиная с наиболее независимых компонентов.  
- **Использование слоистой архитектуры:** разделить систему на слои (например, презентационный, бизнес-логика, доступ к данным), чтобы упростить управление зависимостями.

### Какие подходы к мониторингу и управлению производительностью наиболее эффективны для монолитных архитектур?

- **Централизованный мониторинг:** использование систем, собирающих метрики и логи со всего приложения (например, Prometheus, Grafana, ELK Stack).  
- **Профилирование и трассировка:** применение инструментов для анализа узких мест и отслеживания путей выполнения (например, New Relic, AppDynamics, Jaeger).  
- **Автоматические алерты:** настройка оповещений при превышении пороговых значений по времени отклика, загрузке CPU или памяти.  
- **Регулярное тестирование производительности:** проведение нагрузочного тестирования (например, с помощью JMeter или Gatling) для выявления проблем при росте нагрузки.  
- **Логирование и аналитика:** сбор логов для анализа ошибок и поведения системы в реальном времени.

### Какие технологии и инструменты лучше всего подходят для рефакторинга монолитной архитектуры?

- **Инструменты статического анализа кода:** SonarQube, ESLint, Pylint — помогают выявить проблемные места и улучшить качество кода.  
- **Инструменты для автоматического тестирования:** JUnit, pytest, Selenium — обеспечивают безопасность при внесении изменений.  
- **Инструменты для разделения кода:** Docker, Kubernetes — помогают контейнеризировать части системы для постепенного разделения.  
- **Инструменты CI/CD:** Jenkins, GitLab CI/CD — автоматизируют сборку, тестирование и деплой новых версий.  
- **Рефакторинг-паттерны и практики:** применение принципов SOLID, разделение на модули и слои.

### Какие основные вызовы и проблемы связаны с миграцией с монолитной архитектуры на микросервисную?

- **Сложность разделения системы:** определение границ сервисов требует глубокого анализа бизнес-процессов и зависимостей.  
- **Повышенная сложность инфраструктуры:** управление большим количеством сервисов требует автоматизации оркестрации (например, Kubernetes).  
- **Обеспечение коммуникации между сервисами:** необходимость внедрения API или сообщений (например, REST, gRPC, Kafka).  
- **Проблемы согласованности данных:** обеспечение целостности данных при распределенной архитектуре сложнее.  
- **Риск потери целостности транзакций:** транзакции между сервисами требуют специальных решений (например, Saga pattern).  
- **Значительные временные и ресурсные затраты:** миграция может занять много времени и потребовать дополнительных ресурсов.