Использование **JPQL/HQL** — один из самых эффективных способов **решить проблему N+1** в JPA/Hibernate, потому что позволяет контролировать **какие связи загружать и как формируется SQL**.
## 1️⃣ Суть проблемы
- N+1 возникает, когда у сущностей есть **LAZY-связи**, и для каждой записи Hibernate делает отдельный запрос к базе.
- JPQL/HQL позволяют **подгружать связанные сущности заранее**, формируя оптимальный SQL.
## 2️⃣ Подгрузка связей через `JOIN FETCH`
### Пример:
Есть сущности `Author` и `Book`:
```java
@Entity
public class Author {
    @Id
    private Long id;
    private String name;

    @OneToMany(mappedBy = "author", fetch = FetchType.LAZY)
    private List<Book> books;
}
```
Если написать обычный метод `findAll()`:
```java
List<Author> authors = authorRepository.findAll();
for (Author a : authors) {
    a.getBooks().size(); // N отдельных запросов → N+1
}
```
### Решение через JPQL с `JOIN FETCH`:
```java
@Query("SELECT a FROM Author a LEFT JOIN FETCH a.books")
List<Author> findAllWithBooks();
```
**Что делает Hibernate:**
```sql
SELECT a.*, b.* 
FROM authors a 
LEFT JOIN books b ON a.id = b.author_id;
```
- Все авторы и их книги подгружаются **одним запросом**.
- Проблема N+1 исчезает.
## 3️⃣ Подгрузка нескольких связей
Можно подгружать несколько ленивых связей сразу:
```java
@Query("SELECT a FROM Author a " +
       "LEFT JOIN FETCH a.books " +
       "LEFT JOIN FETCH a.awards")
List<Author> findAllWithBooksAndAwards();
```
**Минус:** если много коллекций → дублируются строки (cartesian product), нужно использовать `DISTINCT`:
```java
@Query("SELECT DISTINCT a FROM Author a " +
       "LEFT JOIN FETCH a.books " +
       "LEFT JOIN FETCH a.awards")
List<Author> findAllDistinct();
```
## 4️⃣ Использование DTO через JPQL
- Вместо загрузки сущностей, выбираем **только нужные поля** через конструктор DTO:
```java
@Query("SELECT new com.example.dto.AuthorDto(a.name, b.title) " +
       "FROM Author a LEFT JOIN a.books b")
List<AuthorDto> findAllAuthorDtos();
```
**Плюсы:**
- Никаких ленивых прокси → N+1 не возникает.
- Меньше данных → выше производительность.
## 5️⃣ Преимущества JPQL/HQL подхода

|Преимущество|Объяснение|
|---|---|
|✅ Контроль SQL|Можно явно указать JOIN и условия|
|✅ Решение N+1|Подгружаем ленивые связи одним запросом|
|✅ Гибкость|Можно фильтровать, сортировать и объединять сущности|
|✅ DTO|Выбираем только нужные поля без лишних данных|
## 6️⃣ Резюме
1. **N+1 возникает** из-за LAZY-связей.
2. **JPQL/HQL с JOIN FETCH** подгружает данные заранее → один SQL вместо 1+N.
3. **DTO через JPQL** полностью исключает ленивые прокси.
4. Для нескольких коллекций используйте `DISTINCT` и фильтры, чтобы избежать дублирования.