## 1️⃣ Через метод `join()` у потоков
- Метод `join()` заставляет **текущий поток ждать**, пока другой поток не завершится.
- Если у вас несколько потоков, можно вызвать `join()` у каждого.
```java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(() -> System.out.println("Поток 1"));
        Thread t2 = new Thread(() -> System.out.println("Поток 2"));

        t1.start();
        t2.start();

        // Ждём завершения потоков
        t1.join();
        t2.join();

        System.out.println("Все потоки завершены");
    }
}
```
- Плюсы: простой и прямой способ.
- Минусы: ручное управление потоками, неудобно при большом количестве потоков.
## 2️⃣ Через `ExecutorService` и `invokeAll()`
- Если используем пул потоков, можно передать **коллекцию задач** и дождаться их завершения.
```java
import java.util.concurrent.*;

public class Main {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        ExecutorService executor = Executors.newFixedThreadPool(2);

        Callable<String> task1 = () -> "Результат задачи 1";
        Callable<String> task2 = () -> "Результат задачи 2";

        // invokeAll блокирует, пока все задачи не завершатся
        java.util.List<Future<String>> results = executor.invokeAll(java.util.List.of(task1, task2));

        for (Future<String> f : results) {
            System.out.println(f.get());
        }

        executor.shutdown();
    }
}
```
## 3️⃣ Через `CountDownLatch`
- Высокоуровневая утилита из `java.util.concurrent`.
- Можно задать **счётчик N**, который уменьшается при завершении каждой задачи.
- Главный поток ждёт, пока счётчик не станет 0.
```java
import java.util.concurrent.CountDownLatch;

public class Main {
    public static void main(String[] args) throws InterruptedException {
        int numThreads = 3;
        CountDownLatch latch = new CountDownLatch(numThreads);

        for (int i = 0; i < numThreads; i++) {
            new Thread(() -> {
                System.out.println("Работа потока: " + Thread.currentThread().getName());
                latch.countDown(); // уменьшаем счётчик
            }).start();
        }

        latch.await(); // ждём, пока все потоки закончат
        System.out.println("Все потоки завершены");
    }
}
```
- Плюсы: удобно для **динамического числа потоков**.
## 4️⃣ Через `CompletableFuture.allOf()`
- Для **асинхронных задач**, удобнее работать с `CompletableFuture`.
- Позволяет дождаться завершения всех задач и продолжить выполнение.
```java
import java.util.concurrent.CompletableFuture;

public class Main {
    public static void main(String[] args) {
        CompletableFuture<Void> f1 = CompletableFuture.runAsync(() -> System.out.println("Поток 1"));
        CompletableFuture<Void> f2 = CompletableFuture.runAsync(() -> System.out.println("Поток 2"));

        // Ждём завершения всех
        CompletableFuture.allOf(f1, f2).join();
        System.out.println("Все потоки завершены");
    }
}
```
- Плюсы: современный, функциональный и неблокирующий подход.
 ### ✅ Итог
**Способы ожидания завершения нескольких потоков:**
1. `Thread.join()` — для ручного управления потоками.
2. `ExecutorService.invokeAll()` — для пула потоков с задачами `Callable`.
3. `CountDownLatch` — гибкий и удобный для динамического числа потоков.
4. `CompletableFuture.allOf()` — современный асинхронный подход.