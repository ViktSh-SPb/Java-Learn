## 1️⃣ Контроль загрузки связей: `fetch = FetchType.LAZY / EAGER`
```java
@OneToMany(fetch = FetchType.LAZY)
private List<Book> books;
```
- **LAZY** — связь загружается только при обращении (по умолчанию для коллекций).
- **EAGER** — связь загружается сразу вместе с сущностью.
**Совет:**
- Для коллекций почти всегда лучше использовать **LAZY**, чтобы избежать лишних JOIN и контролировать SQL через `JOIN FETCH` или DTO.
- EAGER может привести к **лишней загрузке данных** и N+1, если не контролировать запросы.
## 2️⃣ `@BatchSize`
- Позволяет Hibernate подгружать несколько ленивых коллекций **одним пакетом**, уменьшая количество SQL-запросов.
```java
@OneToMany(fetch = FetchType.LAZY)
@BatchSize(size = 10)
private List<Book> books;
```
- Если нужно подгружать книги для 50 авторов: Hibernate сделает **5 запросов по 10 коллекций**, а не 50 отдельных запросов.
## 3️⃣ `@EntityGraph`
- Декларативный способ **указывать, какие связи подгружать** заранее через `fetchgraph`.
```java
@EntityGraph(attributePaths = {"books"})
Optional<Author> findById(Long id);
```
**Плюсы:**
- Решает проблему N+1 без изменения LAZY/EAGER.
- Подходит для Spring Data JPA.
- Можно комбинировать с методами репозитория и фильтрами.
## 4️⃣ `@NamedEntityGraph` (для повторного использования)
- Позволяет создавать именованные графы подгрузки:
```java
@NamedEntityGraph(
    name = "Author.books",
    attributeNodes = @NamedAttributeNode("books")
)
@Entity
public class Author { ... }
```
- Потом использовать:
```java
@EntityGraph(value = "Author.books")
Optional<Author> findById(Long id);
```
**Плюсы:** удобно для повторного использования графов подгрузки в разных запросах.
## 5️⃣ `@JoinColumn` / `@JoinTable` с корректными связями
- Определение правильных `@JoinColumn` помогает Hibernate строить **эффективные JOIN**, уменьшает дубли и лишние запросы.
## 6️⃣ DTO-конструкторы через JPQL (`new`) — аннотации не нужны, но связанный подход
```java
@Query("SELECT new com.example.dto.AuthorDto(a.name, b.title) " +
       "FROM Author a LEFT JOIN a.books b")
List<AuthorDto> findAllAuthorDtos();
```
- Подгружаем **только нужные поля**, N+1 не возникает, ленивых прокси нет.
## 7️⃣ Open Session In View (OSIV) — через конфигурацию
```properties
spring.jpa.open-in-view=true
```
- Держит сессию открытой до конца HTTP-запроса.
- Легко решает LazyInitializationException, но **не всегда предотвращает N+1**, и может ухудшить производительность.
- Рекомендуется только для старых MVC-приложений, не для REST API.
## ✅ Резюме аннотаций и подходов

|Аннотация / подход|Назначение|Примечание|
|---|---|---|
|`fetch = FetchType.LAZY / EAGER`|Контроль когда подгружается связь|Для коллекций почти всегда LAZY|
|`@BatchSize`|Пакетная загрузка нескольких ленивых коллекций|Уменьшает количество SQL-запросов|
|`@EntityGraph` / `@NamedEntityGraph`|Декларативная подгрузка связей|Решает N+1 без изменения fetch|
|`@JoinColumn` / `@JoinTable`|Оптимизация JOIN|Правильное построение SQL|
|DTO через JPQL `new`|Выборка только нужных полей|Полностью исключает ленивые прокси|
|OSIV (`spring.jpa.open-in-view`)|Держит сессию открытой|Решает LazyInitializationException, но N+1 может остаться|
