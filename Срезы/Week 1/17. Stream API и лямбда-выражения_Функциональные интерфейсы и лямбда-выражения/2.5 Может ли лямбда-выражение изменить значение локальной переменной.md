**Коротко:** ❌ **нет, не может**.
Лямбда-выражение в Java **не может изменить значение локальной переменной**, объявленной вне лямбды. Такая переменная должна быть **`final` или _effectively final_**.
## Почему так?
Лямбды **захватывают значение**, а не саму переменную.  
Это сделано ради:
- потокобезопасности
- предсказуемости поведения
- упрощения реализации на уровне JVM
## Пример ❌ (ошибка компиляции)
```java
int count = 0;

Runnable r = () -> {
    count++; // ❌ Local variable count defined in an enclosing scope must be final or effectively final
};
```
Компилятор не пропустит такой код.
## Что такое _effectively final_
Переменная:
- инициализируется один раз
- **не изменяется** после этого
```java
int x = 10;

Runnable r = () -> {
    System.out.println(x); // ✔ OK
};
```
## Как обойти ограничение (если очень нужно)
### 1. Использовать поле класса
```java
class Counter {
    int count = 0;

    Runnable r = () -> count++; // ✔ можно
}
```
### 2. Использовать изменяемый объект
```java
AtomicInteger count = new AtomicInteger(0);

Runnable r = () -> count.incrementAndGet(); // ✔ можно
```
Или:
```java
int[] count = {0};

Runnable r = () -> count[0]++; // ✔ можно, но не рекомендуется
```
### 3. Использовать `collect` вместо мутаций (лучше)
❌ плохо:
```java
int sum = 0;
list.forEach(x -> sum += x);
```
✔ правильно:
```java
int sum = list.stream().mapToInt(Integer::intValue).sum();
```
## Важное отличие от анонимных классов
И там, и там:
- локальные переменные должны быть effectively final
Но:
- у лямбды **нет своего `this`**
- она использует `this` внешнего класса