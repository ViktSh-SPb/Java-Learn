### 1️⃣ S — Single Responsibility Principle (Принцип единственной ответственности)
- Класс должен иметь **только одну причину для изменения**, то есть решать **только одну задачу**.
- Пример: класс `InvoicePrinter` занимается только печатью счёта, а не его расчётом.
### 2️⃣ O — Open/Closed Principle (Принцип открытости/закрытости)
- Класс должен быть **открыт для расширения, но закрыт для изменения**.
- Новое поведение добавляется через **наследование или композицию**, а не изменение существующего кода.
### 3️⃣ L — Liskov Substitution Principle (Принцип подстановки Лисков)
- Подкласс должен быть **взаимозаменяем с базовым классом**, не нарушая корректность работы программы.
- Пример: если функция работает с объектом `Bird`, она должна корректно работать с объектом `Sparrow`, наследником `Bird`.
### 4️⃣ I — Interface Segregation Principle (Принцип разделения интерфейсов)
- Клиенты не должны зависеть от методов, которые они **не используют**.
- Лучше создавать несколько **узкоспециализированных интерфейсов**, чем один большой универсальный.
### 5️⃣ D — Dependency Inversion Principle (Принцип инверсии зависимостей)
- **Модули верхнего уровня не должны зависеть от модулей нижнего уровня напрямую.**
- Оба уровня должны зависеть от **абстракций (интерфейсов)**.
- Пример: сервис `PaymentService` работает с интерфейсом `PaymentProcessor`, а не с конкретной реализацией `CreditCardProcessor`.