### Что такое монолитная архитектура?

- **Монолитная архитектура** — это стиль проектирования программных систем, при котором все компоненты приложения (интерфейс, бизнес-логика, доступ к данным и т.д.) реализованы в едином, тесно связном блоке.
- В такой системе все части работают в рамках одного процесса или развертываются как единое целое.
- Обычно монолитное приложение разрабатывается как одна большая кодовая база.

### В чем основное преимущество монолитной архитектуры перед микросервисной?

- **Простота разработки и развертывания:** все компоненты находятся в одном проекте, что облегчает начальную разработку и тестирование.
- **Легкость интеграции:** взаимодействие между компонентами происходит внутри одного процесса, что устраняет необходимость межсервисной коммуникации.
- **Менее сложная инфраструктура:** не требуется управление несколькими сервисами, оркестрацией или распределенными транзакциями.
- **Более быстрый старт:** проще запустить и протестировать систему на ранних этапах.

### Почему монолитная архитектура может стать проблемой при масштабировании проекта?

- **Трудности масштабирования отдельных компонентов:** поскольку все части связаны вместе, невозможно масштабировать только наиболее нагруженные части — приходится масштабировать всё приложение целиком.
- **Рост сложности и технического долга:** с увеличением объема кода становится сложнее поддерживать и развивать систему.
- **Медленная разработка и внедрение изменений:** любые изменения требуют пересборки и перезапуска всего приложения.
- **Проблемы с гибкостью:** трудно внедрять новые технологии или компоненты без существенных изменений всей системы.
- **Риск отказа всей системы:** сбой в одном компоненте может привести к недоступности всего приложения.

### Какие признаки указывают на то, что пора разделять монолит на микросервисы?

- **Рост сложности и объема кода:** система становится трудно поддерживаемой и развиваемой.
- **Медленная разработка и внедрение новых функций:** изменения требуют долгого времени сборки и тестирования.
- **Высокая связность компонентов:** изменения в одной части системы вызывают многочисленные побочные эффекты.
- **Различные требования к масштабированию:** отдельные части системы требуют разного уровня ресурсов.
- **Команды работают независимо:** необходимость деления работы между командами по функциональным областям.
- **Проблемы с производительностью:** узкие места в системе, которые сложно устранить без разделения.

### Какие риски несет разделение монолитного приложения на микросервисы?

- **Увеличение сложности инфраструктуры:** требуется управление несколькими сервисами, оркестрацией, мониторингом.
- **Проблемы с согласованностью данных:** необходимость реализации механизмов синхронизации и транзакций между сервисами.
- **Повышенная сложность коммуникации:** межсервисное взаимодействие через API или сообщения — возможны задержки и сбои.
- **Дублирование логики и данных:** риск появления избыточных данных или бизнес-логики в разных сервисах.
- **Обеспечение безопасности:** усложняется контроль доступа и аутентификация между сервисами.
- **Требования к навыкам команды:** необходимо наличие специалистов по DevOps, API, распределенным системам.

### Какие преимущества микросервисной архитектуры можно использовать для обоснования ее внедрения вместо монолита?

- **Масштабируемость отдельных компонентов:** возможность масштабировать только нагруженные части системы.
- **Гибкость разработки и внедрения новых функций:** команды работают независимо, быстрее внедряют изменения.
- **Повышенная отказоустойчивость:** сбой одного сервиса не парализует всю систему.
- **Технологическая гибкость:** использование разных технологий и языков программирования для разных сервисов.
- **Лучшее управление сложностью:** разделение системы на логические модули упрощает поддержку и развитие.

### Какие стратегии разделения монолитного приложения на микросервисы вы знаете?

- **Функциональное деление (по бизнес-функциям):** выделение сервисов по бизнес-процессам или доменам (например, заказы, пользователи).
- **Деление по данным (по агрегатам):** создание сервисов вокруг отдельных моделей данных или агрегатов.
- **Деление по техническим слоям:** например, отдельные сервисы для API, обработки данных, аналитики.
- **Постепенное рефакторинг (Strangler Fig pattern):** постепенное замещение частей монолита новыми микросервисами.

### Какие технические и организационные аспекты необходимо учитывать при переходе от монолита к микросервисам?

**Технические:**
- Проектирование API и контрактов между сервисами.
- Обеспечение надежной коммуникации (REST, gRPC, очереди сообщений).
- Управление данными: стратегия репликации, синхронизации, транзакций.
- Мониторинг и логирование распределенной системы.
- Обеспечение безопасности межсервисных взаимодействий.

**Организационные:**
- Перестройка команд: распределение ответственности по функциональным областям.
- Внедрение DevOps-практик для автоматизации деплоя и мониторинга.
- Обучение команд новым технологиям и подходам.
- Постепенное внедрение с минимальными рисками — итеративный подход.

### Какие паттерны проектирования микросервисов помогут минимизировать проблемы с зависимостями и коммуникацией между сервисами?

- **API Gateway:** централизованный вход для всех запросов к микросервисам, упрощает управление зависимостями.
- **Service Registry and Discovery:** автоматическое обнаружение сервисов в динамической среде.
- **Circuit Breaker (предохранитель):** предотвращает цепную реакцию отказов при сбоях в коммуникации.
- **Event-driven architecture (шина событий):** асинхронная коммуникация через события уменьшает зависимость между сервисами.
- **Bulkheads (барьеры):** изоляция ресурсов для предотвращения распространения сбоев.
  
Эти паттерны помогают снизить связанность компонентов, повысить отказоустойчивость и обеспечить более гибкую архитектуру.