**Stream API в Java** — это **инструмент для работы с коллекциями и другими источниками данных** в функциональном стиле. Он появился в **Java 8** и позволяет писать **декларативный код** для фильтрации, преобразования, сортировки и агрегации данных.
## 1. Основная идея
- Поток (`Stream`) — это **последовательность элементов**, над которыми можно выполнять операции.
- Stream **не хранит данные**, а работает с источником (например, `List`, `Set`, массив, I/O, генераторы).
- Stream поддерживает **цепочку операций** и **ленивое вычисление**.
## 2. Основные операции
### 2.1. Создание потока
```java
List<String> names = List.of("Anna", "Bob", "Charlie");

// Из коллекции
Stream<String> stream1 = names.stream();

// Из массива
Stream<Integer> stream2 = Arrays.stream(new Integer[]{1,2,3});
```
### 2.2. Промежуточные операции (intermediate)
Возвращают новый Stream, **ленивые**, выполняются только при терминальной операции.

|Операция|Пример|
|---|---|
|`filter`|`stream.filter(x -> x.startsWith("A"))`|
|`map`|`stream.map(String::toUpperCase)`|
|`sorted`|`stream.sorted()`|
|`distinct`|`stream.distinct()`|
|`limit`|`stream.limit(5)`|
### 2.3. Терминальные операции (terminal)
Запускают обработку и возвращают результат.

|Операция|Пример|
|---|---|
|`forEach`|`stream.forEach(System.out::println)`|
|`collect`|`stream.collect(Collectors.toList())`|
|`reduce`|`stream.reduce(0, Integer::sum)`|
|`count`|`stream.count()`|
|`anyMatch`|`stream.anyMatch(x -> x > 10)`|
## 3. Пример использования
```java
List<String> names = List.of("Anna", "Bob", "Charlie", "Alex");

List<String> filteredNames = names.stream()
    .filter(s -> s.startsWith("A"))   // промежуточная операция
    .map(String::toUpperCase)         // промежуточная операция
    .sorted()                         // промежуточная операция
    .toList();                        // терминальная операция

System.out.println(filteredNames);
```
**Вывод:**
```
[ALEX, ANNA]
```
## 4. Преимущества Stream API
1. **Декларативный стиль** — что делать, а не как.
2. **Ленивая обработка** — операции выполняются только при терминальном вызове.
3. **Компактность кода** — меньше циклов и временных переменных.
4. **Лёгкая работа с параллелизмом** (`parallelStream()`).
5. **Интеграция с лямбдами и функциональными интерфейсами**.
## 5. Важные особенности
- Потоки **не изменяют исходные коллекции**.
- Stream **однократного использования** — после терминальной операции нельзя повторно использовать.
- Легко комбинируется с лямбда-выражениями и method reference.