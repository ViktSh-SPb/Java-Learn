### Что такое состояние гонки и как оно может возникнуть в многопоточной программе?

Состояние гонки (race condition) — это ситуация, когда результат выполнения программы зависит от непредсказуемого порядка выполнения потоков. Оно возникает, когда несколько потоков одновременно обращаются к общему ресурсу или переменной без должной синхронизации, что может привести к некорректным или непредсказуемым результатам.

### Какие основные способы синхронизации потоков вы знаете в Java?

- Использование ключевого слова `synchronized` (блоки и методы).
- Использование классов из пакета `java.util.concurrent`, таких как `ReentrantLock`, `Semaphore`, `CountDownLatch`, `CyclicBarrier`.
- Использование атомарных классов (`AtomicInteger`, `AtomicReference` и др.).
- Использование `volatile` для обеспечения видимости изменений переменных между потоками.
- Использование `Lock` и `Condition` для более гибкой синхронизации.

### Как работает ключевое слово synchronized в Java?

`Synchronized` — это механизм, который обеспечивает взаимное исключение (mutual exclusion). Он блокирует объект или метод, чтобы только один поток мог его выполнять одновременно. При входе в синхронизированный блок или метод поток захватывает монитор объекта; при выходе — освобождает его. Это предотвращает одновременный доступ к разделяемым ресурсам.

### Какие есть проблемы многопоточности Java?

- Состояние гонки (race conditions).
- Мертвая блокировка (deadlock).
- Ливлок (livelock).
- Недостаточная видимость изменений между потоками (`visibility issues`).
- Проблемы с производительностью из-за чрезмерной синхронизации.
- Потеря данных при неправильной работе с разделяемыми ресурсами.

### Что такое потокобезопасность?

Потокобезопасность — это свойство класса или ресурса корректно работать при одновременном доступе из нескольких потоков без возникновения ошибок или некорректных данных. Потокобезопасные классы обеспечивают правильную работу даже при высокой конкуренции.

### Что такое мертвая блокировка (deadlock) и какие условия необходимы для ее возникновения?

Мертвая блокировка — ситуация, когда два или более потока ожидают друг друга освобождения ресурсов, которые они держат, и ни один из них не может продолжить выполнение. Условия возникновения:

1. Взаимное исключение (`mutual exclusion`) — ресурсы неделимы.
2. Удержание и ожидание (`hold and wait`) — потоки удерживают ресурсы и ждут другие.
3. Непреодолимое ожидание (`no preemption`) — ресурсы нельзя принудительно отобрать.
4. Циклическое ожидание (`circular wait`) — цепочка потоков ожидает ресурсы друг друга.

### Как обнаружить и избежать проблему livelock в многопоточных приложениях?

Livelock — ситуация, когда потоки активно меняются состояниями, но не делают прогресса (например, постоянно пытаются захватить ресурс). Для избежания:

- Использовать алгоритмы с экспоненциальным ростом задержек.
- Внедрять тайм-ауты при попытке захвата ресурсов.
- Проектировать логику так, чтобы избегать циклических ожиданий.
- Использовать высокоуровневые механизмы синхронизации, такие как `java.util.concurrent`.

### Какие инструменты мониторинга потоков существуют в Java, и как они используются?

- Thread Dump: вывод состояния всех потоков через `jstack`.
- VisualVM: графический инструмент для мониторинга JVM, позволяет отслеживать активные потоки, их состояние и использование ресурсов.
- Java Mission Control (JMC): профилирование JVM в реальном времени.
- JConsole: мониторинг JVM через JMX. Эти инструменты помогают выявлять блокировки, состояния deadlock и другие проблемы многопоточности.

### Как использовать ReentrantLock и как он отличается от использования synchronized блоков или методов?

`ReentrantLock` предоставляет более гибкий механизм блокировки:

- Можно попытаться захватить блокировку без блокировки (`tryLock()`).
- Можно установить тайм-аут при попытке захвата (`tryLock(timeout)`).
- Поддерживает создание условных переменных (`Condition`) для сложной координации. Отличия:
- Более явное управление блокировками.
- Возможность прерывания ожидания (`interruptible lock acquisition`).
- Необходимость явно освобождать блокировку вызовом `unlock()`.

### Опишите, как работает и для чего используется Condition интерфейс в современном многопоточном программировании.

`Condition` — это интерфейс для реализации условных переменных, аналогичных классическому `Object.wait() / notify()`, но более гибкий:

- Позволяет создавать несколько условий для одного замка (`Lock`).
- Обеспечивает методы `await()`, `signal()`, `signalAll()`. Используется для реализации сложных сценариев ожидания и уведомления между потоками внутри блока с использованием `Lock`.

### Какие стратегии вы бы использовали для оптимизации работы с многопоточностью в высоконагруженной системе?

- Минимизировать область синхронизации (использовать атомарные операции).
- Использовать неблокирующие структуры данных (`ConcurrentHashMap`, `CopyOnWriteArrayList`).
- Разделять задачи на меньшие части для параллельной обработки.
- Использовать пул потоков (`ThreadPoolExecutor`) с правильной настройкой размеров.
- Внедрять асинхронное программирование там, где возможно.
- Профилировать систему для выявления узких мест.

### Что такое потокобезопасный Singleton?

Это реализация паттерна Singleton так, чтобы она была безопасна при использовании в многопоточной среде. Гарантирует создание единственного экземпляра класса без риска создания нескольких объектов при одновременном доступе.

### Способы реализации потогобезопасного Singleton?

1. Использование статического внутреннего класса:

```java
public class Singleton {
    private static class Holder {
        static final Singleton INSTANCE = new Singleton();
    }
    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
```

1. Использование enum:

```java
public enum Singleton {
    INSTANCE;
}
```

1. Двойная проверка Lock:

```java
public class Singleton {
    private static volatile Singleton instance;
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
