# Тестирование
**Тестирование в Java** - важная часть разработки, которая помогает убедиться, что программа работает корректно и устойчиво. В экосистеме Java существует множество инструментов и подходов для тестирования.
## Виды тестирования
### 1. Модульное (юнит-тестирование)
**Unit-тесты (модульные тесты)** - это тесты, которые проверяют отдельные модули кода (обычно классы или методы) изолированно от остальной системы. Их цель - убедиться, что каждая маленькая часть программы работает корректно.
#### Основные принципы
##### 1. Изоляция
Тестируем только один метод/класс. Внешние зависимости *(БД, API*) подменяются заглушками или моками.
##### 2. Повторяемость 
Результат теста должен быть одинаковым при каждом запуске.
##### 3. Быстрота
Unit-тесты выполняются быстро и запускаются часто (обычно при каждой сборке/коммите).
##### 4. Автоматизация
Тесты пишутся так, чтобы их можно было запускать без ручного вмешательства.
##### 5. Принцип AAA (Arrange → Act → Assert)
- **Arrange** - подготовка данных и окружения
- **Act** - выполнение тестируемого метода
- **Assert** - проверка результата
#### Библиотеки:
- **JUnit** (самая популярная)
- **TestNG**
#### Пример (JUnit 5):
```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class CalculatorTest {
	@Test
	void testAdd() {
		Calculator calc = new Calculator();
		assertEquals(5, calc.add(2, 3));
	}
}
```
#### Аннотации JUnit 5

| Аннотация      | Назначение                      |
| -------------- | ------------------------------- |
| `@Test`        | Отметить метод как тестовый     |
| `@BeforeEach`  | Выполняется перед каждым тестом |
| `@AfterEach`   | Выполняется после каждого теста |
| `@BeforeAll`   | Один раз перед всеми тестами    |
| `@AfterAll`    | Один раз после всех тестов      |
| `@Disabled`    | Отключить тест временно         |
| `@DisplayName` | Задает читаемое имя тесту       |

### 2. Интеграционное тестирование
Проверка взаимодействия между компонентами (например, сервис + база данных).
#### Библиотеки:
- **Spring Boot Test** (@SpringBootTest)
- **Testcontainers** (для Docker-сервисов)
- **H2** (встраиваемая БД для тестов)
### 3. Функциональное тестирование
Проверка функционала с точки зрения пользователя.
#### Инструменты:
- **Selenium** (тестирование UI в браузере)
- **REST Assured** (тестирование REST API)
### 4. Тестирование производительности
#### Инструменты:
- **JMH** (Java MicroBenchmark Harness)
- **JMeter**
### 5. Мокинг (имитация зависимостей)
Если наш код зависит от других компонентов, например, баз данных), можно подменить эти компоненты на "заглушки". 
**Мок** - это поддельный (имитированный) объект, который заменяет настоящий объект в тесте и позволяет:
- контролировать поведение зависимостей;
- проверять, вызывались ли нужные методы;
- изолировать тестируемый код от внешних систем (например, базы данных, сетевых API, и т.д.)
#### Библиотеки:
- **Mockito**
- **EasyMock**
#### Пример:
Допустим, есть сервис:
```java
public class OrderService {
	private PaymentService paymentService;

	public OrderService(PaymentService paymentService) {
		this.paymentService = paymentService;
	}

	public boolean placeOrder(Order order) {
		return paymentService.charge(order.getAmount());
	}
}
```
В юнит-тесте мы не хотим вызывать настоящий PaymentService (например, чтобы не делать реальные транзакции). Вместо этого мы используем **мок**.
С использованием библиотеки Mockito:
```java
import static org.mockito.Mockito.*;
import org.junit.jupiter.api.Test;

public class OrderServiceTest {
	@Test
	public void testPlaceOrder() {
		PaymentService mockPayment = mock(PaymentService.class);
		when (mockPayment.charge(100)).thenREturn(true);
		OrderService service = new OrderService(mockPayment);
		Order order = new Order(100);

		boolean result = service.placeOrder(order);

		assertTrue(result);
		verify(mockPayment).charge(100); // проверяем, что метод вызывался
	}
}
```
## Покрытие тестами
Покрытие показывает, какая часть кода была выполнена во время тестов.
#### Инструменты:
- **JaCoCo**
- **Intellij IDEA встроенное покрытие**
## Советы
- Пиши тест перед реализацией (TDD - test-driven development)
- Следи за читабельностью тестов
- Проверяй исключения и граничные случаи
- Разделяй юнит и интеграционные тесты