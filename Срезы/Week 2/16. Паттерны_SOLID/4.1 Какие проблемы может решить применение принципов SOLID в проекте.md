### 1️⃣ Снижение связности (Coupling)
- Принципы **ISP и DIP** уменьшают зависимости между классами.
- Код становится более **модульным и гибким**.
**Проблема без SOLID:** изменения в одном классе ломают работу других.  
**Решение:** зависимости строятся через интерфейсы и абстракции.
### 2️⃣ Повышение расширяемости и повторного использования
- **OCP и SRP** позволяют добавлять новый функционал без изменения существующего кода.
- Можно легко **расширять систему**, минимизируя риск ошибок.
**Проблема без SOLID:** добавление нового поведения требует изменения множества классов.
### 3️⃣ Упрощение тестирования
- Каждый класс решает **одну задачу (SRP)** и зависит только от нужных интерфейсов (ISP, DIP).
- **Модули легко тестировать независимо**.
**Проблема без SOLID:** сложно писать юнит-тесты, потому что классы монолитные и тесно связаны.
### 4️⃣ Предотвращение нарушения контрактов
- **LSP** гарантирует, что подклассы корректно заменяют базовые классы.
- Сохраняется **предсказуемое поведение системы**.
**Проблема без LSP:** подкласс ломает работу кода, использующего базовый класс.
### 5️⃣ Улучшение поддержки и понимания кода
- Принципы SOLID делают код **чистым, модульным и читаемым**.
- Команда быстрее понимает структуру и логику системы.
**Проблема без SOLID:** код сложный, изменения рискованны, документация часто устарела.
### 6️⃣ Итог
Применение SOLID помогает решать такие проблемы:
1. **Высокая связность и низкая модульность**
2. **Сложность расширения и добавления нового функционала**
3. **Трудности в тестировании и поддержке**
4. **Нарушение ожидаемого поведения при наследовании**
5. **Сложность понимания и сопровождения кода**