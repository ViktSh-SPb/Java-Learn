### Что такое лямбда-выражение в Java?

Лямбда-выражение — это короткий способ представить анонимную функцию или блок кода, который можно передавать как объект. Оно позволяет писать более компактный и читаемый код, особенно при работе с функциональными интерфейсами.

---

### Какие преимущества лямбда-выражений вы можете назвать?

- **Краткость и читаемость:** Меньше шаблонного кода по сравнению с анонимными классами.
- **Функциональный стиль программирования:** Упрощают работу с потоками и API, основанными на функциях.
- **Легкость передачи поведения:** Можно передавать блоки кода как параметры.
- **Поддержка ленивых вычислений и цепочек вызовов.**

---

### Что такое функциональный интерфейс в Java?

Функциональный интерфейс — это интерфейс с ровно одним абстрактным методом, который может быть реализован с помощью лямбда-выражения или ссылки на метод. Он служит основой для функционального программирования в Java.

---

### Сколько абстрактных методов может быть в функциональном интерфейсе?

Только один. Наличие более одного абстрактного метода делает интерфейс неконфигурируемым для использования с лямбда-выражениями.

---

### Может ли лямбда-выражение изменить значение локальной переменной?

Нет, лямбда-выражения могут захватывать только **финализированные** или **эффективно финализированные** переменные (то есть те, которые не изменяются после присвоения). Попытка изменить локальную переменную внутри лямбды вызовет ошибку компиляции.

---

### Что такое ссылка на метод?

Это краткая форма для вызова существующего метода или конструктора, которая позволяет использовать его как функциональный интерфейс. Например: `String::toLowerCase` — ссылка на метод `toLowerCase` класса `String`.

---

### Каковы основные характеристики функционального интерфейса в Java?

- Имеет ровно один абстрактный метод.
- Может содержать дефолтные и статические методы.
- Используется как целевой тип для лямбда-выражений и ссылок на методы.
- Аннотируется `@FunctionalInterface` (не обязательно, но рекомендуется).

---

### Какие преимущества и недостатки использования лямбда выражений по сравнению с анонимными классами?

**Преимущества:**
- Более компактный и читаемый код.
- Меньше шаблонных конструкций.
- Легко использовать в потоках и API, основанных на функциях.

**Недостатки:**
- Меньше возможностей для сложной реализации (например, нельзя объявлять поля).
- Труднее отлаживать из-за меньшей прозрачности.
- Не всегда подходит для сложных сценариев.

---

### Как можно использовать лямбда выражения для реализации функциональных интерфейсов?

Пример:
```java
Runnable r = () -> System.out.println("Hello");
````

или

```java
Comparator<String> cmp = (s1, s2) -> s1.length() - s2.length();
```

### Что происходит при захвате переменной из внешнего контекста внутри лямбда-выражения?

Захваченная переменная должна быть эффективно финализирована — то есть не должна изменяться после присвоения. Лямбда создает копию значения переменной, что обеспечивает безопасность многопоточного доступа.

### Как использовать лямбда выражение для сортировки списка строк в обратном порядке с помощью Comparator?

```java
List<String> list = Arrays.asList("apple", "banana", "cherry");
list.sort((s1, s2) -> s2.compareTo(s1));
```

или с помощью метода `Comparator.reverseOrder()`:

```java
list.sort(Comparator.reverseOrder());
```

### Какие стратегии и подходы используются для оптимизации производительности при работе с лямбда выражениями и потоками?

- Использование ленивых вычислений (`Stream`), чтобы избегать ненужных операций.
- Минимизация захвата переменных вне потока.
- Использование методов `parallelStream()` там, где есть выгода от параллелизма.
- Предварительная оптимизация алгоритмов обработки данных.
- Использование эффективных методов коллекций и избегание лишних промежуточных коллекций.

### Как можно создать собственный функциональный интерфейс в Java?

Объявите интерфейс с одним методом и аннотируйте его `@FunctionalInterface`:

```java
@FunctionalInterface
public interface MyFunction {
    int apply(int a, int b);
}
```

Затем его можно реализовать через лямбду:

```java
MyFunction sum = (a, b) -> a + b;
```

### Какие есть способы обработки исключений в лямбда выражениях и Stream API? Приведите пример.

Проблема: стандартные функции не позволяют выбрасывать проверяемые исключения. Решение — обернуть вызов в блок try-catch или создать обертку:

```java
// Обертка для обработки checked исключений
@FunctionalInterface
public interface CheckedFunction<T, R> {
    R apply(T t) throws Exception;
}

public static <T, R> Function<T, R> wrap(CheckedFunction<T, R> func) {
    return t -> {
        try {
            return func.apply(t);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    };
}

// Использование:
Stream.of("file.txt")
      .map(wrap(filename -> Files.readAllLines(Paths.get(filename))))
      .forEach(lines -> lines.forEach(System.out::println));
```

### Объясните различия между методами `andThen` и `compose` в интерфейсе `Function`.

|Метод|Описание|Порядок выполнения|
|---|---|---|
|`andThen`|Выполняет текущую функцию, затем следующую|`(f.andThen(g)).apply(x)` равно `g(f(x))`|
|`compose`|Выполняет другую функцию перед текущей|`(f.compose(g)).apply(x)` равно `f(g(x))`|

Пример:

```java
Function<Integer, Integer> f = x -> x + 2;
Function<Integer, Integer> g = x -> x * 3;

System.out.println(f.andThen(g).apply(4)); // (4 + 2) * 3 = 18
System.out.println(f.compose(g).apply(4)); // (4 * 3) + 2 = 14
```