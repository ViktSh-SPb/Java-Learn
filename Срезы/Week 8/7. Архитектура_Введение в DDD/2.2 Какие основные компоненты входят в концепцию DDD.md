В **DDD (Domain-Driven Design)** есть набор ключевых компонентов и понятий, которые помогают структурировать бизнес-логику и проектировать систему вокруг предметной области.
# ⭐ **Основные компоненты DDD**
## 1. **Entities (Сущности)**
- Объекты с **уникальной идентичностью**, которая сохраняется на протяжении всего жизненного цикла.
- Могут менять своё состояние, но идентификатор остаётся постоянным.
**Пример:**
```kotlin
class Account(val accountId: UUID) {
    var balance: Money = Money(0)
}
```
## 2. **Value Objects (Объекты-значения)**
- Не имеют уникального идентификатора.
- Полностью определяются своими **значениями**.
- Не изменяемы (immutable), при изменении создаётся новый объект.
**Пример:**
```kotlin
data class Money(val amount: BigDecimal, val currency: Currency)
```
## 3. **Aggregates (Агрегаты)**
- **Корневой объект (Aggregate Root)** объединяет связанные сущности и объекты-значения.
- Гарантирует **консистентность данных внутри агрегата**.
- Доступ к внутренним объектам идёт только через корень.
**Пример:**  
`BankAccountAggregate` — корень агрегата `Account`, который управляет операциями (`Deposit`, `Withdraw`).
## 4. **Repositories (Репозитории)**
- Интерфейс для **доступа к агрегатам и сущностям**.
- Скрывает детали хранения (БД, Event Store, внешние сервисы).
**Пример:**
```kotlin
interface AccountRepository {
    fun save(account: Account)
    fun findById(accountId: UUID): Account?
}
```
## 5. **Domain Services (Сервисы домена)**
- Содержат бизнес-логику, которая **не относится к конкретной сущности**.
- Используются для операций, затрагивающих несколько агрегатов.
**Пример:**
```kotlin
class TransferService(
    private val accountRepository: AccountRepository
) {
    fun transfer(from: UUID, to: UUID, amount: Money) { ... }
}
```
## 6. **Domain Events (События домена)**
- Фиксируют **произошедшие изменения в системе**.
- Используются для коммуникации между агрегатами и сервисами.
- Основой для **Event Sourcing и асинхронной интеграции**.
**Пример:**
```kotlin
data class MoneyDeposited(val accountId: UUID, val amount: Money)
```
## 7. **Bounded Contexts (Ограниченные контексты)**
- **Чётко определённые границы модели** и терминологии.
- Внутри контекста понятия и бизнес-правила согласованы.
- Контексты взаимодействуют через **контракты, события или API**.
**Пример:**
- `AccountContext` — управление счетами
- `OrderContext` — управление заказами
- `PaymentContext` — проведение платежей
## 8. **Application Services (Сервисы приложения)**
- Координируют работу доменных агрегатов и сервисов.
- Не содержат бизнес-логики, а управляют **процессом выполнения команд**.
**Пример:**
- `CreateOrderService` вызывает `OrderAggregate`, вызывает события, сохраняет агрегат в репозитории.
## 9. **Factories (Фабрики)**
- Отвечают за **создание агрегатов или сложных объектов**.
- Используются, когда конструктор агрегата слишком сложный для прямого вызова.
# ⭐ **Схематично**
```
[Bounded Context]
   ├── Aggregate Root (Entity + Value Objects)
   ├── Domain Service
   ├── Domain Event
   ├── Repository
   └── Application Service
```
# ⭐ **Итог**
DDD помогает:
- Отделять **бизнес-логику от инфраструктуры**
- Строить систему вокруг **реального бизнеса**
- Обеспечивать **консистентность и ясность модели**
- Поддерживать **масштабируемость и микросервисы** через Bounded Contexts