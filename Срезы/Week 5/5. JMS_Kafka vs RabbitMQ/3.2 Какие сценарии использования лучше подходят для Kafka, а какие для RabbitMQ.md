## 1️⃣ Kafka: когда использовать
Kafka — это **распределённая система потоковой передачи данных**, ориентированная на **масштабируемость, долговременное хранение и обработку потоков**.
### Основные сценарии:

| Сценарий                                                            | Почему Kafka подходит                                                                            |
| ------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------ |
| **Сбор и анализ логов / событий**                                   | Kafka хранит все события в топиках с ретеншн-политикой. Можно читать несколько раз для анализа.  |
| **Stream processing / ETL**                                         | Потоковое преобразование данных с использованием Kafka Streams, Flink, Spark Streaming.          |
| **Большие потоки данных / Data pipelines**                          | Высокая пропускная способность, горизонтальное масштабирование через партиции.                   |
| **Event sourcing**                                                  | Хранение всей истории событий и возможность воспроизвести состояние.                             |
| **Pub/Sub для множества потребителей**                              | Consumer groups позволяют разным приложениям читать одни и те же данные независимо.              |
| **Интеграция между микросервисами, где важна надёжность и ретеншн** | Можно хранить сообщения на длительное время, повторное чтение, гарантии порядка внутри партиции. |

**Ключевые характеристики Kafka:**
- Высокая производительность для больших объёмов данных
- Долговременное хранение сообщений (ретеншн)
- Поддержка масштабируемых consumer group
- Упорядочивание сообщений внутри партиции
## 2️⃣ RabbitMQ: когда использовать
RabbitMQ — это **очереди сообщений с гибкой маршрутизацией**, ориентированная на **доставку и обработку задач в реальном времени**.
### Основные сценарии:

|Сценарий|Почему RabbitMQ подходит|
|---|---|
|**Task queues / распределение задач**|Work queues позволяют нескольким worker-ам обрабатывать задачи параллельно, с балансировкой нагрузки.|
|**Системы с требованиями «at least once delivery»**|Механизм ACK/confirm гарантирует, что сообщение обработано и не потеряно.|
|**Сложная маршрутизация сообщений**|Exchanges: Direct, Topic, Fanout, Headers позволяют гибко направлять сообщения в разные очереди.|
|**Интеграция микросервисов с динамическим маршрутом**|Можно направлять одно сообщение сразу в несколько сервисов через Fanout/Topic.|
|**События, где важна низкая задержка**|RabbitMQ хорошо справляется с маленькими сообщениями и быстрыми уведомлениями.|
|**Сценарии request/response**|RPC-подход (reply-to queue) удобен для синхронного обмена между сервисами.|

**Ключевые характеристики RabbitMQ:**
- Гибкая маршрутизация через exchange
- Подтверждения сообщений (ACK/NACK)
- Подходит для real-time задач и распределения задач
- Небольшие задержки при доставке сообщений
## 3️⃣ Основные различия в применении

|Характеристика|Kafka|RabbitMQ|
|---|---|---|
|Модель|Log-based, immutable stream|Queue-based, push model|
|Хранение|Длительное (лог с ретеншн)|Короткое, пока сообщение не обработано|
|Масштабирование|Горизонтально через партиции|Горизонтально через очереди и кластеры, сложнее|
|Поддержка маршрутизации|Только partition key|Direct, Fanout, Topic, Headers|
|Подход|Event streaming|Task queue / pub-sub / RPC|
|Потребители|Consumer group, offset tracking|Round-robin, ACK/NACK|
### 4️⃣ Итог
- **Kafka** лучше, когда нужно:
    - Обрабатывать **потоки данных**, логировать события, строить **pipelines**, работать с event sourcing.
- **RabbitMQ** лучше, когда нужно:
    - Управлять **очередями задач**, доставкой сообщений в реальном времени, **сложная маршрутизация**, RPC и балансировка между воркерами.