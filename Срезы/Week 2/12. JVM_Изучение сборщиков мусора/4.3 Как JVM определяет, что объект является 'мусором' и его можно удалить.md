В **Java** определение того, что объект является «мусором», лежит на уровне **JVM** и её **сборщика мусора (Garbage Collector, GC)**. JVM использует **анализ достижимости объектов** — если объект недоступен из какой-либо «корневой точки», он считается мусором.
### 1️⃣ Корневые объекты (GC Roots)
JVM начинает проверку с так называемых **GC Roots**. К ним относятся:
- Локальные переменные и параметры методов, находящиеся в стеке текущих потоков.
- Активные объекты в статических полях классов.
- Объекты, используемые в JNI (Java Native Interface).
- Ссылки из класса `java.lang.Thread` (например, текущий выполняемый поток).
### 2️⃣ Достижимость (Reachability)
JVM строит граф объектов, начиная с **GC Roots**, и отмечает все объекты, к которым можно добраться **по ссылкам**:
- **Strong references (сильные ссылки)** – обычные ссылки, которые не позволяют объекту быть собранным.
- **Soft references (мягкие ссылки)** – объекты могут быть удалены при нехватке памяти.
- **Weak references (слабые ссылки)** – объекты удаляются при следующей сборке мусора, даже если есть слабая ссылка.
- **Phantom references (фантомные ссылки)** – используются для финализации и очистки ресурсов после удаления объекта.
Если объект **не достижим** ни из одного GC Root через цепочку ссылок, JVM считает его **мусором**.
### 3️⃣ Алгоритмы GC
Разные сборщики мусора используют разные подходы:
- **Mark-and-Sweep (CMS, Serial, Parallel)**:
    1. **Mark** – помечает все достижимые объекты.
    2. **Sweep** – удаляет все непомеченные (недостижимые) объекты.
- **Copying (Copy, G1, Shenandoah, ZGC)**:
    - Перемещает живые объекты в новое место памяти, а старое пространство, где остались недостижимые объекты, очищает целиком.
- **Generational GC**:
    - Молодое поколение (Young Generation) очищается чаще, так как объекты здесь живут недолго.
    - Старое поколение (Old Generation) очищается реже.
### 4️⃣ Пример
```java
public class TestGC {
    public static void main(String[] args) {
        Object obj1 = new Object(); // сильная ссылка
        Object obj2 = new Object();

        obj1 = null; // obj1 теперь недостижим → кандидат на сборку мусора
        System.gc(); // вызов GC (не гарантирует немедленную сборку)
    }
}
```
Здесь `obj1` после присвоения `null` становится **недостижимым**, поэтому JVM может его удалить при следующей сборке мусора.