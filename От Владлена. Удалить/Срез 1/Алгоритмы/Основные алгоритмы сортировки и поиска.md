### Опишите принцип алгоритма сортировки пузырьком?

- **Принцип:** многократное проходение по массиву, сравнивание соседних элементов и их обмен, если они расположены в неправильном порядке. После каждого прохода самый большой элемент "всплывает" в конец массива. Процесс повторяется, пока массив не станет отсортирован.

---

### Объясните, как работает линейный поиск.

- **Работа:** последовательно просматривает каждый элемент массива или списка, сравнивая его с искомым значением. Если совпадение найдено — возвращает индекс или элемент; если нет — продолжает до конца структуры данных.

---

### Какова основная идея бинарного поиска?

- **Идея:** работает на отсортированных данных, делит массив пополам и сравнивает искомое значение с центральным элементом. В зависимости от результата ищет в левой или правой половине. Процесс повторяется рекурсивно или итеративно, пока не найдёт элемент или не сузит диапазон до пустого.

---

### Какова асимптотическая сложность алгоритма сортировки вставками?

- **Сложность:** 
  - В худшем и среднем случаях — O(n²)
  - В лучшем случае (уже отсортированный массив) — O(n)

---

### Опишите принцип алгоритма сортировки слиянием.

- **Принцип:** рекурсивно делит массив пополам до получения массивов из одного элемента, затем последовательно сливает отсортированные подмассивы в один отсортированный массив. Использует вспомогательные массивы для объединения.

---

### В чем преимущество алгоритма быстрой сортировки по сравнению с другими алгоритмами сортировки?

- **Преимущества:**
  - Обычно работает быстрее на практике благодаря хорошей локализации данных
  - Средняя сложность — O(n log n)
  - Простая реализация и высокая эффективность для больших данных

---

### Как реализовать алгоритм сортировки подсчетом на Java?

```java
public static void countingSort(int[] arr) {
    int max = Arrays.stream(arr).max().getAsInt();
    int[] count = new int[max + 1];

    // Подсчет количества каждого элемента
    for (int num : arr) {
        count[num]++;
    }

    // Обновление массива отсортированными значениями
    int index = 0;
    for (int i = 0; i < count.length; i++) {
        while (count[i] > 0) {
            arr[index++] = i;
            count[i]--;
        }
    }
}
````

### Какие стратегии оптимизации могут быть применены к алгоритму быстрой сортировки?

- Выбор хорошего опорного элемента (например, медиана)
- Использование вставки для малых подмассивов
- Тройной разбиение (3-медиана)
- Параллельная реализация для больших данных
- Ограничение глубины рекурсии для предотвращения худших случаев

### Опишите процесс реализации алгоритма поиска в глубину на графе.

- Процесс:
    1. Начинаем с выбранной вершины.
    2. Помечаем её как посещённую.
    3. Рекурсивно вызываем поиск для всех её соседних вершин, которые ещё не посещены.
    4. Продолжаем до тех пор, пока все достижимые вершины не будут посещены.
- Используется стековая структура вызовов или явный стек для обхода.

| Алгоритм поиска                     | Лучший случай             | Средний случай             | Худший случай               |
|-------------------------------------|---------------------------|----------------------------|------------------------------|
| Линейный поиск                     | O(1) (если искомый элемент — первый) | O(n)                        | O(n)                         |
| Бинарный поиск                     | O(1) (если искомый элемент — средний) | O(log n)                   | O(log n) (при равномерном распределении и правильной реализации) |

---

| Алгоритм сортировки                  | Лучший случай             | Средний случай             | Худший случай               |
|-------------------------------------|---------------------------|----------------------------|------------------------------|
| Сортировка пузырьком                | O(n) (если массив уже отсортирован) | O(n^2)                     | O(n^2)                       |
| Сортировка вставками                | O(n) (если массив уже отсортирован) | O(n^2)                     | O(n^2)                       |
| Быстрая сортировка                  | O(n log n) (при хорошем выборе опорного элемента) | O(n log n)               | O(n^2) (при плохом выборе опорного элемента, например, уже отсортированный массив при выборе первого или последнего элемента в качестве опорного) |
| Сортировка слиянием                 | O(n log n)                | O(n log n)                 | O(n log n)                   |