В **Java** `lazy initialization` (отложенная инициализация) означает, что объект создаётся только при первом обращении. Если её неправильно настроить в многопоточности, могут возникнуть **классические проблемы видимости и гонок**, определяемые **Java Memory Model (JMM)**.
### 1️⃣ Проблемы при неправильно настроенном lazy initialization
#### a) **Дублирование объектов / race condition**
- Если несколько потоков одновременно видят, что объект ещё не создан, они могут создать **несколько экземпляров**.
```java
class Lazy {
    private static Resource instance;

    public static Resource getInstance() {
        if (instance == null) { // несколько потоков видят null
            instance = new Resource(); // создают несколько объектов
        }
        return instance;
    }
}
```
- **Проблема:** не атомарно, несколько потоков могут одновременно войти в блок и создать разные объекты.
#### b) **Неправильная видимость полей**
- Даже если создан только один объект, **поток может увидеть его неполностью инициализированным**, из-за **reordering** и отсутствия happens-before.
```java
class Resource {
    final int value;
    Resource() {
        value = 42;
    }
}

class Lazy {
    private static Resource instance;

    public static Resource getInstance() {
        if (instance == null) {
            instance = new Resource(); // unsafe publication
        }
        return instance;
    }
}
```

- Поток B может получить ссылку на `instance`, но ещё не увидеть корректное значение `value` — из-за неправильной публикации объекта.
### 2️⃣ Способы решения
#### a) **Synchronized метод / блок**
```java
class Lazy {
    private static Resource instance;

    public static synchronized Resource getInstance() {
        if (instance == null) {
            instance = new Resource();
        }
        return instance;
    }
}
```
- Гарантирует **атомарность и видимость** через `synchronized`.
- Минус: каждый вызов блокирует поток (производительность).
#### b) **Double-checked locking с volatile**
```java
class Lazy {
    private static volatile Resource instance;

    public static Resource getInstance() {
        if (instance == null) {
            synchronized(Lazy.class) {
                if (instance == null) {
                    instance = new Resource();
                }
            }
        }
        return instance;
    }
}
```
- Использование `volatile` гарантирует корректную **видимость и безопасную публикацию**
- Популярный вариант для высокопроизводительной ленивой инициализации.
#### c) **Initialization-on-demand holder idiom**
```java
class Lazy {
    private static class Holder {
        static final Resource INSTANCE = new Resource();
    }

    public static Resource getInstance() {
        return Holder.INSTANCE;
    }
}
```
- Потокобезопасный, без синхронизации.
- JVM гарантирует, что `Holder.INSTANCE` создаётся **только при первом обращении** (без гонок и видимости проблем).
#### d) **Использование `AtomicReference`**
```java
import java.util.concurrent.atomic.AtomicReference;

class Lazy {
    private static AtomicReference<Resource> instance = new AtomicReference<>();

    public static Resource getInstance() {
        instance.compareAndSet(null, new Resource());
        return instance.get();
    }
}
```
- Атомарная публикация без блокировок.
- Гарантирует корректное создание и видимость объекта.
### ✅ Итог
**Проблемы lazy initialization в многопоточности:**
1. Дублирование объектов (race condition).
2. Неправильная видимость полей (unsafe publication).
3. Нарушение порядка инициализации из-за reordering.
**Решения:**
- `synchronized` блок или метод.
- Double-checked locking с `volatile`.
- Initialization-on-demand holder idiom.
- Атомарные классы (`AtomicReference`).