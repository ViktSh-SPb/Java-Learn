В **Java** ключевое слово `volatile` используется для **обеспечения корректной видимости переменной между потоками** и предотвращения некоторых оптимизаций компилятора/CPU, которые могут нарушить корректность многопоточного кода. Давай разберём подробно.
### 1️⃣ Основное назначение `volatile`
1. **Гарантия видимости (Visibility)**
    - Изменения `volatile`-переменной в одном потоке **немедленно становятся видимыми** другим потокам.
    - Без `volatile` поток может работать с **кэшированной локальной копией переменной**, и другие потоки изменения не увидят.
2. **Запрет переупорядочивания (Ordering)**
    - JMM запрещает компилятору и CPU переупорядочивать чтения/записи `volatile`-переменных относительно других `volatile`-операций.
    - Гарантирует **happens-before** между записью и последующим чтением той же переменной.
### 2️⃣ Что `volatile` не делает
- **Не делает операции атомарными**, кроме простых чтений и записей.
    ```java
    volatile int counter = 0;
    counter++; // НЕ атомарно! Нужно AtomicInteger или synchronized
    ```
- **Не заменяет полноценную синхронизацию**. Если нужна блокировка и комплексные операции — лучше `synchronized` или атомарные классы из `java.util.concurrent.atomic`.
### 3️⃣ Примеры использования
**Пример 1 — Флаг завершения:**
```java
class Flag {
    volatile boolean done = false;
}

Flag flag = new Flag();

Thread t1 = new Thread(() -> {
    // делаем работу
    flag.done = true; // запись видна всем потокам
});

Thread t2 = new Thread(() -> {
    while (!flag.done) {
        // без volatile здесь может быть бесконечный цикл
    }
});
```
**Пример 2 — Ленивая инициализация (Double-checked Locking):**
```java
class Singleton {
    private static volatile Singleton instance;

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class) {
                if (instance == null) {
                    instance = new Singleton(); // volatile гарантирует корректный конструктор
                }
            }
        }
        return instance;
    }
}
```
### 4️⃣ Ключевые моменты
- `volatile` подходит для **простых флагов и индикаторов состояния**, когда нужна **видимость изменений между потоками**.
- Для **сложных операций (инкременты, модификации коллекций)** нужна синхронизация или атомарные классы.
- Работает только для **instance и static переменных**; локальные переменные всегда потокобезопасны, так как находятся в стеке каждого потока.