Лямбда-выражения используются **как реализация функционального интерфейса**, то есть **заменяют анонимный класс**, реализуя его **единственный абстрактный метод**.
## 1. Базовый принцип
Функциональный интерфейс задаёт _контракт_, а лямбда — _реализацию этого метода_.
```java
@FunctionalInterface
interface Action {
    void execute();
}
```
Реализация через лямбду:
```java
Action action = () -> System.out.println("Выполнено");
action.execute();
```
Компилятор:
- видит тип `Action`
- знает сигнатуру `execute()`
- сопоставляет её с лямбдой
## 2. Замена анонимного класса
### Было (анонимный класс):
```java
Runnable r = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello");
    }
};
```
### Стало (лямбда):
```java
Runnable r = () -> System.out.println("Hello");
```
## 3. Использование стандартных функциональных интерфейсов
### `Predicate<T>`
```java
Predicate<Integer> isPositive = x -> x > 0;
```
### `Function<T, R>`
```java
Function<String, Integer> length = s -> s.length();
```
### `Consumer<T>`
```java
Consumer<String> printer = s -> System.out.println(s);
```
### `Supplier<T>`
```java
Supplier<User> userSupplier = () -> new User();
```
## 4. Передача лямбды в метод
```java
public void process(List<Integer> list, Predicate<Integer> filter) {
    list.stream()
        .filter(filter)
        .forEach(System.out::println);
}
```
Использование:
```java
process(numbers, x -> x % 2 == 0);
```
## 5. Лямбды и Stream API
```java
List<String> names = List.of("Ann", "Bob", "Alexander");

List<Integer> lengths = names.stream()
    .map(s -> s.length())
    .toList();
```
Каждая лямбда — реализация:
- `Predicate`
- `Function`
- `Consumer`
## 6. Использование method reference вместо лямбды
Если лямбда просто вызывает метод:
```java
Consumer<String> printer = System.out::println;
```
Эквивалентно:
```java
Consumer<String> printer = s -> System.out.println(s);
```
## 7. Пользовательский функциональный интерфейс
```java
@FunctionalInterface
interface Validator<T> {
    boolean validate(T value);
}
```
Реализация:
```java
Validator<String> notEmpty = s -> !s.isBlank();
```
## 8. Ограничения, о которых важно помнить
❗ только **один абстрактный метод**  
❗ локальные переменные — `final` или `effectively final`  
❗ лямбда не имеет состояния