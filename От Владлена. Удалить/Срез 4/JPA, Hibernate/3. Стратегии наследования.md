## Что такое стратегия наследования в контексте JPA / Hibernate?

Стратегия наследования — это способ отображения и хранения иерархии классов-сущностей в базе данных. Она определяет, как будут структурированы таблицы и как будут связаны данные для классов-наследников.

---

## Каковы основные стратегии наследования, поддерживаемые JPA?

JPA поддерживает три основные стратегии:

1. Single Table (`InheritanceType.SINGLE_TABLE`)  
    — все классы и их поля хранятся в одной таблице. Используется дискриминатор для определения типа.
    
2. Joined (`InheritanceType.JOINED`)  
    — каждому классу соответствует отдельная таблица, связанные по ключу. Общие поля хранятся в базовой таблице.
    
3. Table per Class (`InheritanceType.TABLE_PER_CLASS`)  
    — у каждого класса есть своя таблица со всеми полями, включая унаследованные. Нет общей таблицы.
    

---

## Как указать стратегию наследования в JPA с помощью аннотаций?

Используйте аннотацию `@Inheritance` на базовом классе:

```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE) // или JOINED, TABLE_PER_CLASS
@DiscriminatorColumn(name = "type")
public abstract class Animal {
    @Id
    private Long id;
    // общие поля
}
```

Для конкретных подклассов:

```java
@Entity
@DiscriminatorValue("dog")
public class Dog extends Animal {
    // поля для Dog
}
```

---

## Какие преимущества и недостатки имеет стратегия SINGLE_TABLE при использовании в JPA / Hibernate?

Преимущества:

- Высокая производительность при чтении — все данные в одной таблице.
- Простота реализации.
- Минимум соединений при запросах.

Недостатки:

- Таблица может стать очень широкой и раздуваться.
- Наличие nullable полей для данных, характерных только для некоторых подклассов.
- Меньшая гибкость при изменениях структуры.

---

## Как работает стратегия JOINED в контексте наследования сущностей в JPA / Hibernate?

При использовании `JOINED`:

- Каждому классу соответствует отдельная таблица.
- Общие поля хранятся в базовой таблице.
- Поля подкласса — в его собственной таблице.
- При запросе Hibernate выполняет `JOIN` между таблицами для получения полной информации.

Это обеспечивает нормализованную структуру базы данных и избегает избыточных nullable полей.

---

## В чем различие между стратегиями TABLE_PER_CLASS и SINGLE_TABLE в JPA?

|Характеристика|SINGLE_TABLE|TABLE_PER_CLASS|
|---|---|---|
|Таблиц создается|Одна|Одна на класс (подкласс)|
|Производительность|Высокая (без JOIN)|Меньше оптимизирована, т.к. каждая таблица самостоятельна|
|Нормализация|Низкая (таблица раздувается)|Высокая (каждая таблица содержит все поля)|
|Nullable поля|Да (для неподдерживаемых свойств)|Нет (каждая таблица содержит только свои поля)|
|Поддержка polymorphic queries|Легко|Могут быть сложнее|

---

## Какие особенности реализации стратегии наследования TABLE_PER_CLASS в Hibernate по сравнению с другими стратегиями?

- Каждому подклассу создается отдельная таблица со всеми полями.
- Нет общей таблицы или объединения через `JOIN`.
- При запросе Hibernate использует `UNION ALL` для получения данных по всей иерархии.
- Производительность может снижаться из-за объединения (`UNION`), особенно при больших объемах данных.
- Не поддерживается `@DiscriminatorColumn`.

Hibernate реализует эту стратегию с помощью специальных SQL-запросов, что иногда усложняет оптимизацию.

---

## Как стратегия наследования влияет на производительность запросов в JPA / Hibernate?

- SINGLE_TABLE: быстрее, так как все данные хранятся в одной таблице без JOIN. Но может быть медленнее при очень широкой таблице или большом количестве nullable полей.
    
- JOINED: медленнее из-за необходимости выполнять `JOIN` между таблицами, особенно при сложных запросах или глубокой иерархии.
    
- TABLE_PER_CLASS: может быть менее эффективной из-за необходимости выполнять `UNION` при запросах по всей иерархии.
    

Выбор зависит от требований к скорости чтения/записи и структуры данных.

---

## Как реализовать кастомную стратегию наследования в JPA / Hibernate, не предусмотренную стандартом?

JPA/Hibernate позволяют создавать собственные стратегии через:

1. Создание собственного `IdentifierGenerator` — для генерации ключей.
2. Использование расширений Hibernate — реализовать собственный `org.hibernate.tuple.entity.EntityTuplizer`.
3. Использование пользовательских аннотаций или расширение существующих механизмов.

Например, можно реализовать свою стратегию отображения через внедрение собственных `UserType` или `AttributeConverter`, а также управлять схемой базы данных вручную или через миграции.

Также можно использовать расширяемость Hibernate через его API для создания новых способов хранения данных, но это требует глубокого понимания внутренней архитектуры фреймворка.