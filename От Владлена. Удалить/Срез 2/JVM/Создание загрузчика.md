### Что такое загрузчик классов в Java?

Загрузчик классов — это компонент JVM, который отвечает за динамическую загрузку байт-кода классов в память во время выполнения программы. Он ищет, читает и преобразует файлы `.class` в объекты `Class`, делая их доступными для JVM.

### Какие виды загрузчиков классов существуют в JVM?

1. Bootstrap Class Loader (Родительский или Ядро-загрузчик) — встроен в JVM, загружает основные системные классы Java из `rt.jar` или аналогичных системных библиотек.
2. Extension Class Loader (Загрузчик расширений) — загружает классы из папки расширений (`jre/lib/ext`) или указанных путей.
3. System (или Application) Class Loader (Системный или прикладной) — загружает пользовательские классы из путей, указанных в classpath.

### Для чего нужен загрузчик классов в Java?

- Динамическая загрузка классов во время выполнения программы.
- Обеспечение модульности и расширяемости приложений.
- Реализация механизмов плагинов и модулей.
- Обеспечение безопасности и изоляции разных частей системы через разные загрузчики.

### Как работает механизм делегирования загрузки классов в Java?

Модель делегирования предполагает, что при запросе на загрузку класса:

1. Загрузчик сначала делегирует задачу своему родительскому загрузчику (`parent`).
2. Родительский загрузчик пытается найти и загрузить класс.
3. Если родитель не может найти класс, только тогда текущий загрузчик вызывает свой собственный метод `findClass()`.

Это обеспечивает безопасность и предотвращает дублирование одних и тех же классов разными загрузчиками.

### Можно ли создать собственный загрузчик классов в Java? Если да, то как?

Да, можно.
Для этого нужно:

- Создать класс, наследующий `java.lang.ClassLoader`.
- Переопределить метод `findClass(String name)`, где реализовать логику поиска и чтения байт-кода класса из нестандартных источников.
- Вызвать `defineClass()` для преобразования байт-кода в объект `Class`.

Пример:

```java
public class MyClassLoader extends ClassLoader {
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] classBytes = ... // получить байты класса из нестандартного источника
        return defineClass(name, classBytes, 0, classBytes.length);
    }
}
```

### Какие особенности безопасности следует учитывать при создании собственного загрузчика классов?

- Изоляция: избегайте возможности подгрузки неподписанных или вредоносных классов.
- Подписи и проверка целостности: проверяйте байт-код перед определением класса.
- Контроль доступа: ограничивайте доступ к ресурсам и данным при чтении байт-кода.
- Обработка ошибок: корректно обрабатывайте исключения при ошибках чтения или определения класса.
- Политика безопасности (`SecurityManager`) — используйте его для ограничения действий загруженных классов.

### Опишите процесс загрузки класса в JVM и как он связан с моделью делегирования

Процесс:

1. Вызов метода `loadClass()` у конкретного `ClassLoader`.
2. Делегирование задачи родительскому (`parent`) загрузчику.
3. Родительский пытается найти класс; если успешно — возвращает его.
4. Если родитель не нашел класс — текущий загружает его через `findClass()`.
5. После успешной загрузки класс связывается с системой исполнения.

Это обеспечивает централизованный контроль за тем, какие классы загружаются и кем.

### Как загрузчик классов может влиять на пространство имен классов?

- Каждый класс связан с конкретным экземпляром `ClassLoader`.
- Одинаковое имя класса, загруженное разными загрузчиками, считается разными типами (`class A from loader1 != class A from loader2`).
- Это позволяет иметь несколько версий одного класса одновременно (например, плагины), что важно для модульных систем или плагинов.

### В чем преимущества создания собственного загрузчика для нестандартных источников?

- Возможность загружать классы из баз данных, сетевых ресурсов или архивов по своему протоколу.
- Обеспечение динамической подгрузки обновлений без перезапуска приложения.
- Реализация системы плагинов или модулей с собственной логикой поиска и проверки.
- Повышение уровня безопасности за счет контроля источников и проверки целостности.