### Что такое Stream API в Java?

Stream API — это набор интерфейсов и методов, введённых в Java 8, который позволяет обрабатывать последовательности данных (например, коллекции) в декларативном стиле. Он облегчает выполнение операций фильтрации, преобразования, агрегации и других над данными с помощью цепочек методов.

### Как создать поток из коллекции в Java с использованием Stream API?

Можно вызвать метод `stream()` у коллекции:

```java
List<String> list = Arrays.asList("a", "b", "c");
Stream<String> stream = list.stream();
```

Для параллельной обработки — `parallelStream()`:

```java
Stream<String> parallelStream = list.parallelStream();
```

### Для чего используются лямбда-выражения в контексте Stream API?

Лямбда-выражения позволяют задавать операции обработки элементов потока (например, фильтрацию или преобразование) компактно и читаемо. Они реализуют функциональные интерфейсы, необходимые для методов Stream API.

### Что такое коныерные и терминальные операторы?

- Промежуточные (конвейерные) операторы: возвращают новый поток и позволяют цеплять операции (`filter()`, `map()`, `sorted()`, `distinct()`). Они ленивы — выполняются только при вызове терминальной операции.
- Терминальные операторы: завершают цепочку и возвращают результат или побочные эффекты (`collect()`, `forEach()`, `reduce()`, `findFirst()`, `count()`). После их вызова поток считается закрытым.

### Можно ли использовать один и тот же поток дважды?

Нет. После выполнения терминальной операции поток считается закрытым и повторное использование вызывает исключение `IllegalStateException`.

### Объясните разницу между методами findFirst() и findAny()

- `findFirst()` — возвращает первый элемент потока в порядке его обработки. Гарантирует порядок.
- `findAny()` — может вернуть любой элемент потока. В параллельных потоках он может выбрать любой подходящий элемент для повышения производительности.


### Как с помощью Stream API отфильтровать элементы коллекции по определенному критерию?

Используйте метод `filter()`:

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
List<Integer> evenNumbers = numbers.stream()
                                   .filter(n -> n % 2 == 0)
                                   .collect(Collectors.toList());
```

### Как преобразовать каждый элемент коллекции в другой тип данных с использованием Stream API?

Используйте метод `map()`:

```java
List<String> strings = Arrays.asList("1", "2", "3");
List<Integer> ints = strings.stream()
                           .map(Integer::parseInt)
                           .collect(Collectors.toList());
```

### Что делает метод collect() в Stream API, и какие существуют варианты его использования?

`collect()` — терминальный оператор, который собирает элементы потока в коллекцию или другую структуру данных. Обычно используют класс `Collectors`:

- `.collect(Collectors.toList())`
- `.collect(Collectors.toSet())`
- `.collect(Collectors.toMap())`
- `.collect(Collectors.joining())`

Пример:

```java
List<String> list = stream.collect(Collectors.toList());
```

### Что такое Stateless и Stateful операции?

- Stateless операции: не зависят от предыдущих элементов или состояния потока (`filter()`, `map()`, `flatMap()`). Они могут выполняться независимо друг от друга.
- Stateful операции: требуют хранения состояния или анализа всей части потока перед результатом (`sorted()`, `distinct()`, `limit()`, `skip()`). Они могут влиять на порядок выполнения и требуют полного прохода по данным.

### Как реализовать параллельную обработку данных с использованием Stream API?

Используйте метод `parallelStream()` вместо `stream()`:

```java
list.parallelStream()
    .filter(...)
    .map(...)
    .collect(...);
```

Это позволяет распараллелить обработку на нескольких ядрах CPU для повышения производительности.

### Какие особенности работы с состоянием в лямбда-выражениях и Stream API следует учитывать для избежания проблем?

- Не изменяйте внешние переменные внутри лямбд (они должны быть финализированы или эффективно финализированы).
- Избегайте использования мутируемых переменных вне потоков.
- При использовании состояния внутри потоков убедитесь, что оно потокобезопасно.
- Не используйте переменные общего состояния без синхронизации.

### Как использовать метод reduce() в Stream API для агрегации данных, и какие подводные камни могут возникнуть при его использовании?

`reduce()` объединяет элементы потока по заданной функции:

```java
int sum = numbers.stream()
                 .reduce(0, (a, b) -> a + b);
```

или без начального значения:

```java
Optional<Integer> sumOpt = numbers.stream()
                                  .reduce((a, b) -> a + b);
```

Подводные камни:

- Необходимость правильного выбора аккумулятора.
- Потенциальная потеря информации при неправильной реализации.
- Неэффективность при использовании без начального значения (может вернуть Optional).

### Можно ли использовать Stream для чтения большого файла?

Да. Можно создать стрим из файла через методы вроде:

```java
try (Stream<String> lines = Files.lines(Paths.get("largefile.txt"))) {
    lines.filter(...)
         .forEach(...);
}
```

Это удобно для обработки больших файлов без загрузки всего содержимого в память.

### Объясните, как работает терминальный метод reduce()

`reduce()` объединяет все элементы потока в один результат с помощью функции объединения. Например:

```java
int product = stream.reduce(1, (a, b) -> a * b);
```

Здесь начальное значение — 1; функция умножения объединяет элементы. Если поток пустой — возвращается начальное значение.