### Какие основные состояния потоков в Java?

Основные состояния потоков:

- NEW — поток создан, но еще не запущен.
- RUNNABLE — поток выполняется или готов к выполнению.
- BLOCKED — поток ожидает освобождения монитора (блокировки).
- WAITING — поток ожидает уведомления (`notify()`) или другого потока.
- TIMED_WAITING — поток находится в состоянии ожидания с тайм-аутом (например, `sleep()`, `wait(timeout)`).
- TERMINATED — поток завершил выполнение.

### Как создать новый поток в Java?

Можно создать поток несколькими способами:

- Наследовать класс `Thread` и переопределить метод `run()`:

```java
class MyThread extends Thread {
    public void run() {
        // код потока
    }
}
MyThread t = new MyThread();
t.start();
```

- Реализовать интерфейс `Runnable` и передать его в конструктор `Thread`:

```java
Runnable task = () -> {
    // код задачи
};
Thread t = new Thread(task);
t.start();
```

- Использовать лямбда-выражения (с Java 8+):

```java
Thread t = new Thread(() -> {
    // код
});
t.start();
```

### Что такое метод join() в контексте потоков и для чего он используется?

Метод `join()` используется для ожидания завершения другого потока. Когда вызывается `thread.join()`, текущий поток приостанавливается до тех пор, пока указанный поток не завершит выполнение. Это полезно для синхронизации и последовательного выполнения задач.

Пример:

```java
thread1.start();
thread1.join(); // текущий поток ждет завершения thread1
// далее выполняется после завершения thread1
```

### Чем отличаются Runnable и Callable?

- `Runnable`: интерфейс с методом `run()`, не возвращает результат и не выбрасывает проверяемые исключения.
- `Callable<V>`: интерфейс с методом `call()`, который возвращает результат типа `V` и может выбрасывать исключения.

Преимущество `Callable` — возможность получать результат выполнения задачи и обрабатывать исключения. Для этого используют `FutureTask`.

### Какие методы используются для приостановки и возобновления работы потока?

Основные методы:

- `sleep(milliseconds)` — приостанавливает текущий поток на заданное время.
- `wait()` — вызывает ожидание до получения уведомления (`notify()` или `notifyAll()`), должен вызываться внутри синхронизированного блока.
- `notify()` / `notifyAll()` — пробуждают один или все ожидающие потоки внутри синхронизированного блока.

Для возобновления работы потока обычно используют эти механизмы совместно.

### Чем отличается метод sleep() от wait()?

- `sleep()` — статический метод класса `Thread`, приостанавливает текущий поток на заданное время, не освобождая монитор.
- `wait()` — вызывается внутри синхронизированного блока или метода, приостанавливает текущий поток до получения уведомления (`notify()`), освобождая монитор, что позволяет другим потокам его захватывать.

### Как работает метод interrupt() и в каких случаях он используется?

Метод `interrupt()` посылает сигнал прерывания потоку. Если поток находится в состоянии ожидания (`sleep()`, `wait()`, блокировка), он выбрасывает исключение `InterruptedException`. Это используется для прерывания долгих операций или остановки потока по требованию.

Пример:

```java
thread.interrupt();
```

Поток должен периодически проверять состояние прерывания через метод `isInterrupted()` или ловить исключение для корректной обработки.

### Как реализовать безопасное взаимодействие между потоками при использовании общих ресурсов?

Используйте механизмы синхронизации:

- ключевое слово `synchronized` для защиты критических секций;
- классы из пакета `java.util.concurrent`, такие как блокирующие очереди (`BlockingQueue`), семафоры (`Semaphore`), атомарные переменные (`AtomicInteger`) и другие средства для безопасного обмена данными без явных блокировок.

Пример с блокирующей очередью:

```java
BlockingQueue<String> queue = new ArrayBlockingQueue<>(10);
```

### Какие стратегии можно использовать для управления состоянием потоков в многопоточной среде?

Стратегии включают:

- Использование блокировок (`synchronized`, ReentrantLock) для защиты данных;
- Использование атомарных переменных (`AtomicInteger`) для атомарных операций;
- Использование механизмов координации (`CountDownLatch`, `CyclicBarrier`);
- Использование пулов потоков (`ExecutorService`) для управления количеством активных потоков;
- Правильное управление состояниями через вызовы методов `.join()`, `.interrupt()`, `.sleep()`.

### Каким образом можно реализовать паттерн «один производитель - много потребителей» в многопоточной программе на Java?

Используйте блокирующие очереди (`BlockingQueue`). Производитель добавляет элементы, а несколько потребителей извлекают их:

```java
BlockingQueue<String> queue = new ArrayBlockingQueue<>(100);

class Producer implements Runnable {
    public void run() {
        // добавление элементов
        queue.put("item");
    }
}

class Consumer implements Runnable {
    public void run() {
        String item = queue.take(); // извлечение элемента
        // обработка
    }
}
```

### Что такое volatile?

Ключевое слово `volatile` гарантирует видимость изменений переменной между потоками. Объявленная как volatile переменная всегда читается из основной памяти, а не из кеша каждого потока, что предотвращает проблемы с согласованностью данных.

Пример:

```java
volatile boolean flag = false;
```

Используется для флагов завершения работы или других признаков состояния, чтобы изменения были видимы всем потокам без использования блокировок.