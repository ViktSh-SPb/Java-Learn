В контексте **Stream API** лямбда-выражения используются для **определения поведения, которое должно выполняться над элементами потока**. Они позволяют писать **короткий и читаемый функциональный код** без создания отдельных классов или анонимных объектов.
## 1. Основное назначение
Лямбда-выражения в Stream API реализуют **функциональные интерфейсы**, которые требуются для различных операций потока:
- `Predicate<T>` — для фильтрации (`filter`)
- `Function<T,R>` — для преобразования (`map`)
- `Consumer<T>` — для потребления элементов (`forEach`)
- `Supplier<T>` — для создания элементов (например, при генерации потока)
## 2. Примеры использования
### 2.1. Фильтрация (`filter`)
```java
List<Integer> numbers = List.of(1, 2, 3, 4, 5);

List<Integer> evenNumbers = numbers.stream()
    .filter(n -> n % 2 == 0) // Predicate
    .toList();

System.out.println(evenNumbers); // [2, 4]
```
### 2.2. Преобразование (`map`)
```java
List<String> names = List.of("Anna", "Bob");

List<Integer> lengths = names.stream()
    .map(s -> s.length()) // Function
    .toList();

System.out.println(lengths); // [4, 3]
```
### 2.3. Действие над элементами (`forEach`)
```java
names.stream()
     .forEach(s -> System.out.println(s.toUpperCase())); // Consumer
```
### 2.4. Агрегация (`reduce`)
```java
int sum = numbers.stream()
                 .reduce(0, (a, b) -> a + b); // BinaryOperator
System.out.println(sum); // 15
```
## 3. Почему это удобно
1. **Короткий и читаемый код**  
    Не нужно создавать анонимные классы или отдельные методы.
2. **Декларативный стиль**  
    Вы описываете _что_ нужно сделать, а не _как_ перебрать коллекцию.
3. **Легко комбинировать**  
    Несколько операций можно «цепочкой»:
```java
numbers.stream()
       .filter(n -> n % 2 == 0)
       .map(n -> n * n)
       .forEach(System.out::println);
```
4. **Поддержка параллельной обработки**  
    Лямбды легко работают с `parallelStream()` для многопоточных вычислений.
## 4. Коротко
> В Stream API лямбда-выражения используются для передачи логики обработки элементов потока: фильтрации, преобразования, агрегации и действий над элементами, реализуя соответствующие функциональные интерфейсы (`Predicate`, `Function`, `Consumer`, `BinaryOperator` и др.).