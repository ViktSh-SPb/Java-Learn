В **JUnit 5** параметризованные тесты позволяют **запускать один и тот же тестовый метод с разными входными данными**. Это удобно, когда нужно проверить одну функциональность с множеством вариантов без дублирования кода.
## 1️⃣ Подключение зависимости
Если используете Maven:
```xml
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-params</artifactId>
    <version>5.10.0</version>
    <scope>test</scope>
</dependency>
```
Для Gradle:
```gradle
testImplementation 'org.junit.jupiter:junit-jupiter-params:5.10.0'
```
## 2️⃣ Аннотация `@ParameterizedTest`
- Вместо обычного `@Test` используем `@ParameterizedTest`.
- Данные передаются через **источники данных** (`@ValueSource`, `@CsvSource`, `@MethodSource`, `@EnumSource`).
### 2.1 Использование `@ValueSource`
Для простых типов (int, String, etc.):
```java
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import static org.junit.jupiter.api.Assertions.assertTrue;

class NumberTest {

    @ParameterizedTest
    @ValueSource(ints = {2, 4, 6, 8})
    void testEvenNumbers(int number) {
        assertTrue(number % 2 == 0);
    }
}
```
- Тест выполнится **4 раза**, один раз для каждого значения.
### 2.2 Использование `@CsvSource`
Для передачи нескольких аргументов:
```java
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

import static org.junit.jupiter.api.Assertions.assertEquals;

class CalculatorTest {

    @ParameterizedTest
    @CsvSource({
        "2, 3, 5",
        "0, 5, 5",
        "-1, 1, 0"
    })
    void testAdd(int a, int b, int expected) {
        Calculator calc = new Calculator();
        assertEquals(expected, calc.add(a, b));
    }
}
```
- Каждый набор чисел (`a, b, expected`) запускает отдельный тест.
### 2.3 Использование `@MethodSource`
Для более сложных данных или объектов:
```java
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;

import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.assertEquals;

class CalculatorTest {

    static Stream<Object[]> provideNumbers() {
        return Stream.of(
            new Object[]{2, 3, 5},
            new Object[]{0, 5, 5},
            new Object[]{-1, 1, 0}
        );
    }

    @ParameterizedTest
    @MethodSource("provideNumbers")
    void testAdd(int a, int b, int expected) {
        Calculator calc = new Calculator();
        assertEquals(expected, calc.add(a, b));
    }
}
```
- Метод `provideNumbers` возвращает поток данных, который используется тестом.
### 2.4 Использование `@EnumSource`
Для тестирования всех значений enum:
```java
enum Color { RED, GREEN, BLUE }

class ColorTest {

    @ParameterizedTest
    @EnumSource(Color.class)
    void testColorEnum(Color color) {
        assertNotNull(color);
    }
}
```
- Тест запустится для каждого значения `Color.RED`, `Color.GREEN`, `Color.BLUE`.
## 3️⃣ Преимущества параметризованных тестов
1. Сокращают дублирование кода.
2. Легко тестировать разные сценарии с одними и теми же проверками.
3. Хорошо интегрируются с CI/CD и отчетами JUnit.