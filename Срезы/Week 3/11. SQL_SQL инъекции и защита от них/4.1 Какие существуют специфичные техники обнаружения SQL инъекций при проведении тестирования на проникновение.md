## Важное предупреждение
Все перечисленные техники **должны применяться только в условиях законного теста (authorized penetration test / bug-bounty / аудит по контракту)**. Неправомерное сканирование и эксплуатация уязвимостей — преступление.
## Краткая стратегия обнаружения (high-level)
1. Инвентаризация входных точек (GET/POST, headers, cookies, JSON, XML, file uploads, HTTP methods, websocket/API).
2. Быстрая мануальная проверка на простые инъекции.
3. Автоматизированное сканирование (с ограничениями).
4. Глубокий анализ «слепых» векторов (boolean/time/OOB).
5. Валидация и подтверждение (без причинения вреда) — чтение метаданных, не дамп базы.
6. Документирование с PoC, но без эксплойта данных.
## Методы и техники (подробно)
### 1. Инвентаризация параметров
Перечислить ВСЕ точки ввода:
- URL-параметры, тело POST (form, JSON, XML), cookies, headers (User-Agent, Referer), multipart/form-data и upload fields, REST endpoints, GraphQL, WebSocket.  
    Именно в нетипичных местах часто прячутся уязвимости.
**Индикатор**: любое место, где пользовательский ввод попадает в SQL-запрос на сервере.
### 2. Простые мануальные проверки (quick checks)
- Вставить непечатный символ/одиночную кавычку в параметр и смотреть на поведение (ошибки, изменение ответа, http-код, длину тела).
- Проверять различие поведения при разных вводах — быстрый способ заметить потенциальную уязвимость.
**Индикаторы**: появление SQL-ошибок, изменения в HTML, неожиданная разная длина ответа.
> Примечание: не используйте эти проверки на боевых критичных данных; лучше — тестовая среда.
### 3. Error-based (ошибко-ориентированное) обнаружение
- Посмотреть, выбрасывает ли приложение подробные сообщения БД (syntax error, column not found, type cast error).
- Подмена входа может вызвать явные ошибки, позволяющие узнать СУБД (MySQL, PostgreSQL, MSSQL, Oracle дают разные тексты).
**Индикатор**: в теле ответа/логе появляются SQL-ошибки с подсказками о СУБД.
### 4. Boolean-based (логические / «слепые») тесты
- Меняем вход так, чтобы условие было истинно/ложно и сравниваем ответы (станет ли страница «правдой»/«ложью»).
- Это позволяет извлечь информацию бит за битом, даже при отсутствии ошибок.
**Индикатор**: различие в содержимом, коде ответа, времени ответа или поведении приложения.
### 5. Time-based (временные / «слепые») тесты
- Вставляем конструкции, которые заставят СУБД задержать ответ (sleep), и проверяем изменение задержки.
- Полезно, когда приложение не возвращает ошибки, но выполняет инъцируемый SQL.
**Индикатор**: устойчивое увеличение времени отклика при специально сформированном вводе.
### 6. UNION / content-based тесты
- Проверить возможность объединения результирующих наборов (`UNION SELECT ...`) и получить контролируемый вывод (например, специфический текст), если сайт выводит содержимое SQL-результата в ответе.
**Индикатор**: вставка управляемого контента в ответ страницы.
### 7. Stacked queries (множественные операторы)
- Проверить, разрешает ли СУБД выполнение нескольких операторов в одном запросе — это даёт возможность выполнить дополнительные команды (внимание: очень опасно).
- Многие драйверы/СУБД по умолчанию запрещают; это редкий, но критичный вектор.
**Индикатор**: выполнение вторых операторов (например, создание видимого эффекта).
### 8. Out-of-Band (OOB) / External Interaction
- Если приложение может инициировать сетевые запросы из БД (например, через UDFs, xp_cmdshell, HTTP функции), можно получить подтверждение через внешний канал (DNS/HTTP callback).
- OOB используется, когда прямой вывод невозможен.
**Индикатор**: появление внешнего трафика к контролируемому домену.
### 9. Second-order injection
- Данные вводятся как безопасные, но позже используются в другом контексте (например, сохранены в базе, затем используются в динамическом SQL).
- Нужно тестировать потоки данных end-to-end.
**Индикатор**: баг проявляется при повторном использовании введённого значения.
### 10. Фокус на современные API (JSON / GraphQL / REST / SOAP)
- JSON body, GraphQL queries — инъекции могут быть в полях, заголовках, даже внутри JSON-поиска.
- GraphQL: операции и поля тоже проверять на пользовательскую подстановку.
**Индикатор**: неожиданный результат при изменении значений в JSON или GraphQL аргументах.
### 11. Техники обхода WAF / фильтров
- Кодирование (URL-encoding, UTF-8), комментарии внутри, разделение полезной нагрузки, изменение пробелов, case switching, использование эквивалентов функций.
- Цель — понять, какие фильтры включены и как их обойти в рамках теста.
**Важно:** обход WAF разрешён только в рамках согласованного теста.
## Инструменты (для тестирования и автоматизации)
- **sqlmap** — автоматический инструмент для поиска и эксплуатации SQLi (настройте rate / не используйте без разрешения).
- **Burp Suite (Intruder, Scanner)** — ручное/полуавтоматическое тестирование; мощная поддержка payload-lists и tamper-скриптов.
- **OWASP ZAP** — сканер/тестер, полезен для автоматизации.
- **Nmap NSE scripts**, **sqlninja**, **jSQL**, **Nikto** — вспомогательные инструменты.
- **Custom scripts** — curl/python + requests для тонкой проверки и логирования.
## Что смотреть в ответе/логах — индикаторы успешной инъекции
- Разные коды ответа (500, 502), текст ошибки СУБД, изменение длины тела ответа, изменение структуры страницы, появление или исчезновение элементов, задержки во времени ответа, обратный внешний трафик (для OOB).
## Как подтверждать уязвимость безопасно (этика и техника)
- Используйте тестовую/стейдж среду, если она есть.
- Не выгружайте реальные конфиденциальные данные.
- Для доказательства применяйте «неразрушающие» PoC: контролируемый ввод, который подтверждает уязвимость (изменение длины/времени/ошибки), а не дамп таблиц.
- Документируйте шаги и логи, чтобы воспроизвести проблему инженерам.
## Частые ошибки при тестировании (чего избегать)
- Полагаться только на автоматические сканеры — они пропускают слепые векторы.
- Игнорировать нетипичные места ввода (headers, cookies, file names, XML attributes).
- Работать без разрешения или на продакшн-данных.
- Делать разрушительные payload-ы (DROP, DELETE) в продакшне.
## Как определять СУБД по симптомам (fingerprinting)
- Тексты ошибок, поведение функций (sleep, concatenation), синтаксис (LIMIT vs TOP, `||` vs `+`), наличие специфичных функций (pg_sleep, SLEEP, BENCHMARK, xp_cmdshell). Это помогает подобрать корректные payload-типы для дальнейшей проверки.
## Примеры полезных шаблонов тестирования (концептуально)
- Проверка реакции на «спецсимволы» (кавычки, скобки).
- Сравнение ответа при «условие = true» vs «условие = false» (boolean blind).
- Измерение времени при условии, приводящем к задержке (time blind).
- Попытка встраивания контролируемого вывода через UNION (если приложение включает данные в ответ).
(Я сознательно даю концептуальные шаблоны — точные payload-строки и эксплойты выполнять только в рамках авторизованного теста.)
## Рекомендации по автоматизации и workflow
1. Соберите инвентарь параметров (спайдинг).
2. Быстрый пасс с Burp/OWASP ZAP + кастомными payload lists.
3. Ручной пасс на обнаруженные точки (boolean/time/OOB).
4. Доп. проверка second-order и API/GraphQL.
5. Подготовка отчёта с PoC, impact, репродукцией и рекомендациями по исправлению.
## Рекомендации по защите (чтобы в отчёте было полезно)
- Параметризованные запросы / PreparedStatements.
- Валидация по белому списку для динамических идентификаторов.
- Минимальные DB-привилегии и отключение многозапросного выполнения.
- Логирование аномалий и WAF как дополнительный барьер.
- Регулярные SAST/DAST и ревью мест, где формируется SQL.