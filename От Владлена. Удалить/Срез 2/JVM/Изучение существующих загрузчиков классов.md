### Какие три основных загрузчика классов существуют в JVM?

1. Bootstrap Class Loader (Родительский или Ядро-загрузчик) — встроен в JVM, загружает основные классы Java из `rt.jar` или аналогичных системных библиотек.
2. Extension Class Loader (Загрузчик расширений) — загружает классы из папки расширений (`jre/lib/ext`) или указанных путей.
3. System (или Application) Class Loader (Системный или прикладной загрузчик) — загружает пользовательские классы из classpath, т.е. из путей, указанных при запуске JVM.

### Что такое загрузчик классов в Java?

Загрузчик классов — это компонент JVM, который отвечает за динамическую загрузку байт-кода классов в память во время выполнения программы. Он ищет и читает файлы `.class`, создает соответствующие объекты `Class`, и связывает их с системой выполнения.

### Какой загрузчик классов используется по умолчанию для загрузки пользовательских классов?

По умолчанию используется системный (или прикладной) загрузчик (`Application Class Loader`). Он загружает пользовательские классы из путей, указанных в classpath.

### Какие задачи выполняет системный (или прикладной) загрузчик классов?

- Загружает пользовательские и сторонние классы из указанных путей.
- Обеспечивает механизм поиска и чтения `.class` файлов.
- Делегирует загрузку более "старшим" загрузчикам при необходимости.
- Связывает байт-код с объектами `Class` для дальнейшего использования.

### Как можно написать собственный загрузчик классов и для чего это может потребоваться?

Создание собственного загрузчика осуществляется путем наследования класса `ClassLoader` и переопределения метода `findClass()`.  
Это может понадобиться для:

- Загрузки классов из нестандартных источников (например, базы данных, сети).
- Реализации плагинов или модульных систем.
- Обеспечения динамической подгрузки обновлений без перезапуска приложения.

Пример:

```java
public class MyClassLoader extends ClassLoader {
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        byte[] classData = ... // получить байты класса
        return defineClass(name, classData, 0, classData.length);
    }
}
```

### Как работает делегирование загрузки классов в Java?

Модель делегирования предполагает, что при запросе на загрузку класса:

1. Загрузчик сначала делегирует задачу своему родительскому (`parent`) загрузчику.
2. Если родитель не сможет найти класс, только тогда он вызывает свой собственный метод `findClass()`.

Это обеспечивает безопасность и предотвращает дублирование одних и тех же классов разными загрузчиками.  
Пример цепочки:  
`CustomClassLoader -> SystemClassLoader -> BootstrapClassLoader`

### Как решается проблема разрешения циклических зависимостей между классами при загрузке?

Циклические зависимости могут возникнуть при взаимных ссылках между классами. JVM решает это следующим образом:

- Каждый класс загружается один раз; повторная попытка не вызывает повторную загрузку.
- В процессе связывания (`linking`) создаются ссылки между классами.
- Если циклическая зависимость возникает во время статической инициализации, JVM ждет завершения инициализации всех участвующих классов перед продолжением.

Важно избегать сложных циклических зависимостей в статической части кода, чтобы избежать ошибок.

### Какие методы класса `ClassLoader` используются для загрузки классов?

- `loadClass(String name)` — основной метод для запуска процесса поиска и загрузки класса с делегированием.
- `findClass(String name)` — переопределяемый метод для поиска конкретного класса по имени (используется внутри `loadClass()`).
- `defineClass()` — создает объект `Class` из массива байтов байт-кода.
- `resolveClass()` — связывает класс после его загрузки.

### Как JVM обрабатывает случай, когда два разных загрузчика классов загрузили классы с одинаковыми именами?

В JVM каждый класс уникален по своему уникальному идентификатору, который включает:

- Имя класса
- Загрузчик, который его загрузил

Если два разных загрузчика загружают класс с одинаковым именем:

- Они считаются двумя разными типами (`class A from loader1 != class A from loader2`).
- Это может привести к проблемам совместимости или ClassCastException при попытке привести объекты к одному типу.

JVM позволяет иметь несколько версий одного класса в памяти одновременно, если они загружены разными загрузчиками. Это используется например в плагинных системах или приложениях с модульной архитектурой.