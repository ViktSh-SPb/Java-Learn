## 🔹 Как работает CAS в Java
1. В Java CAS реализован через **атомарные классы** из пакета `java.util.concurrent.atomic` (`AtomicInteger`, `AtomicLong`, `AtomicReference` и др.).
2. Под капотом CAS использует **низкоуровневые инструкции процессора** (например, `CMPXCHG` на x86), которые **гарантируют атомарность операции** на уровне CPU.
3. CAS проверяет текущее значение переменной, и если оно совпадает с ожидаемым, записывает новое значение **атомарно**. Если нет — операция не выполняется, поток может повторить попытку.
4. Для Java это обеспечивает **lock-free и thread-safe** работу с переменными.
## 🔹 Пример: использование AtomicInteger с CAS

```java
import java.util.concurrent.atomic.AtomicInteger;

public class CasExample {
    private static AtomicInteger counter = new AtomicInteger(0);

    public static void main(String[] args) throws InterruptedException {
        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                int oldValue;
                int newValue;
                do {
                    oldValue = counter.get();           // читаем текущее значение
                    newValue = oldValue + 1;           // вычисляем новое значение
                } while (!counter.compareAndSet(oldValue, newValue)); // пытаемся установить новое значение
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        t1.start();
        t2.start();

        t1.join();
        t2.join();

        System.out.println("Итоговое значение: " + counter.get());
    }
}
```
**Что происходит:**
1. Поток читает текущее значение `oldValue`.
2. Вычисляет новое значение `newValue`.
3. `compareAndSet(oldValue, newValue)` проверяет: если значение переменной всё ещё равно `oldValue`, оно атомарно меняется на `newValue`.
4. Если другой поток успел изменить значение, CAS возвращает `false`, и операция повторяется (spin-loop).
## 🔹 Преимущества CAS
- **Lock-free**: не блокирует другие потоки.
- **Повышает производительность** при высокой конкуренции.
- **Обеспечивает потокобезопасность** без использования `synchronized`.
 