### Что такое unit-тестирование?

Unit-тестирование — это метод проверки отдельных компонентов или модулей программного обеспечения в изоляции от остальной системы. Цель — убедиться, что каждый модуль работает правильно, выполняет свои функции и соответствует требованиям. Обычно такие тесты автоматизированы и выполняются быстро.

### Что такое заглушка (stub) в контексте тестирования ПО?

Заглушка (stub) — это упрощенная реализация зависимости, которая возвращает заранее заданные значения или имитирует поведение, необходимое для проведения теста. Она используется для изоляции тестируемого компонента от внешних систем или сложных зависимостей.

### Какие преимущества дают фреймворки для модульного тестирования?

- Автоматизация выполнения тестов, что ускоряет процесс разработки.
- Обеспечение повторяемости и предсказуемости результатов.
- Легкое создание и управление тестовыми сценариями.
- Поддержка параметризации тестов, что позволяет проверять разные сценарии.
- Интеграция с системами сборки и CI/CD, что повышает качество выпускаемой продукции.

### В чем разница между заглушкой (stub) и макетом (mock)?

|Характеристика|Заглушка (Stub)|Макет (Mock)|
|---|---|---|
|Основная роль|Возвращает фиксированные значения|Проверяет взаимодействия, вызовы методов|
|Поведение|Статичное, заранее заданное|Динамическое, с проверками вызовов|
|Использование|Для возврата данных|Для проверки правильности взаимодействий|
|Пример|Метод возвращает фиксированный результат|Метод ожидает вызова с определенными аргументами|

Кратко:

- Заглушки — подставные объекты, возвращающие предопределенные данные.
- Моки — объекты, которые не только предоставляют данные, но и проверяют, что с ними взаимодействуют правильно.

### Как можно использовать макеты (mocks) для тестирования взаимодействия между компонентами?

Пример:

```java
// Создаем мок для интерфейса
PaymentGateway mockGateway = Mockito.mock(PaymentGateway.class);

// Определяем поведение
when(mockGateway.processPayment(any(PaymentRequest.class)))
    .thenReturn(new PaymentResponse(true));

// Внедряем мок в компонент
OrderService orderService = new OrderService(mockGateway);

// Выполняем действие
orderService.placeOrder(order);

// Проверяем взаимодействие
verify(mockGateway).processPayment(any(PaymentRequest.class));
```

Это позволяет убедиться, что компонент вызывает зависимость правильно.

### Какие существуют библиотеки для создания заглушек и макетов в Java?

- Mockito — популярная библиотека для создания моков и заглушек.
- JMock — еще один инструмент для мокирования объектов.
- EasyMock — библиотека для создания моков с поддержкой декларативного определения поведения.
- PowerMock — расширение Mockito/JMock для работы с статическими методами и конструкторами.

### Какие принципы следует учитывать при проектировании тестов, использующих заглушки и макеты?

- Изоляция: Тестируемый компонент должен быть полностью изолирован от внешних зависимостей.
- Ясность: Тесты должны быть понятными и легко читаемыми.
- Минимизация логики в заглушках: Заглушки должны содержать минимальную логику — только то, что необходимо для сценария.
- Повторное использование: Создавайте универсальные фабрики или шаблоны для создания заглушек/макетов.
- Предсказуемость: Заглушки должны возвращать ожидаемые результаты для каждого сценария.
- Покрытие различных сценариев: Включайте тесты на успешные случаи, ошибки и исключения.

### Какие подходы и методологии могут быть использованы для тестирования ПО в микросервисной архитектуре?

- Контейнеризация и изоляция сервисов (например, Docker) для воспроизведения окружения.
- Использование контрактных тестов (например, Pact) для проверки взаимодействия между сервисами.
- Мокирование зависимостей, API-заглушки или симуляторы внешних систем.
- Тестирование контрактов API, чтобы убедиться в совместимости сервисов.
- Автоматизированное интеграционное тестирование, включая end-to-end сценарии.
- Непрерывная интеграция и доставка, чтобы быстро выявлять регрессии.

### Как реализовать параметризованные тесты в JUnit для проверки поведения с различными входными данными?

Пример с JUnit 5:

```java
@ParameterizedTest
@CsvSource({
    "input1, expected1",
    "input2, expected2",
    "input3, expected3"
})
void testWithDifferentInputs(String input, String expected) {
    // Ваша логика теста
    String result = someMethod(input);
    assertEquals(expected, result);
}
```

или с помощью `@MethodSource`:

```java
@ParameterizedTest
@MethodSource("provideInputs")
void testWithMethodSource(String input, String expected) {
    // Тестовая логика
}

static Stream<Arguments> provideInputs() {
    return Stream.of(
        Arguments.of("input1", "expected1"),
        Arguments.of("input2", "expected2")
    );
}
```
