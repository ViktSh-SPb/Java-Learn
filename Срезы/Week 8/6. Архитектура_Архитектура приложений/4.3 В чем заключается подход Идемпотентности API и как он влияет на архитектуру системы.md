**Идемпотентность API** — это принцип, при котором **повторный вызов одного и того же API с одинаковыми параметрами приводит к тому же результату**, что и первый вызов, без побочных эффектов.
Иными словами, **несколько одинаковых запросов не меняют состояние системы больше, чем один**.
# ⭐ **Принцип работы**
- Если клиент случайно повторяет запрос (из-за таймаута, сбоя сети или повторной попытки), результат **не ломает систему**.
- Обычно идемпотентность гарантируется для методов:
    - **GET** — всегда идемпотентен (только чтение)
    - **PUT** — обновление ресурса до конкретного состояния
    - **DELETE** — удаление ресурса (повторный вызов ничего не ломает)
Пример:
```http
PUT /accounts/123
{
  "balance": 1000
}
```
- Первый вызов создаёт или обновляет баланс.
- Второй вызов с тем же payload оставляет баланс 1000, без ошибок и дублирования.
# ⭐ **Влияние на архитектуру системы**
1. **Повышенная надежность при сетевых сбоях**
    - Клиент может безопасно повторять запросы.
    - В микросервисах уменьшает вероятность **двойного изменения состояния**.
2. **Упрощение реализации retry-механизмов**
    - Сервисы могут повторять операции без риска испортить данные.
    - В сочетании с Circuit Breaker и Eventual Consistency становится безопаснее.
3. **Улучшение масштабируемости**
    - Легче строить асинхронные очереди и брокеры сообщений.
    - Повторные события не портят систему (например, Kafka, RabbitMQ).
4. **Упрощение интеграции между сервисами**
    - Сервисы могут вызывать друг друга повторно без сложной логики защиты от дублей.
5. **Влияние на дизайн API и хранилищ данных**
    - Появляется необходимость **идемпотентных ключей/токенов**
    - Пример: `idempotency_key` для POST-запросов (создание заказа).
    - Логику нужно проектировать так, чтобы **одно событие приводило к одному изменению состояния**.
# ⭐ **Пример в микросервисной архитектуре**
- Сервис заказов получает POST `/orders` с `idempotency_key`.
- Если запрос повторился, сервис проверяет ключ в базе и возвращает уже созданный заказ, **без дублирования транзакций**.
- В сочетании с Event Sourcing это гарантирует консистентность событий.
# ⭐ **Итог**
Идемпотентность API помогает:
- Сделать систему **устойчивой к сбоям сети и повторным запросам**
- Упростить логику **retry и компенсации**
- Облегчить **интеграцию микросервисов и обработку событий**