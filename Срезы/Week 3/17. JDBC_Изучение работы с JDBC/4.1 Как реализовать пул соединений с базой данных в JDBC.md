## Коротко — зачем нужен пул соединений
- Открытие/закрытие JDBC-соединения дорого (TCP, аутентификация).
- Пул держит фиксированное число уже открытых соединений и раздаёт их приложению по запросу.
- Преимущества: значительно меньше задержек при запросах, контроль числа одновременных соединений, централизованная настройка параметров.
## Популярные реализации
- **HikariCP** — быстрый, лёгкий, рекомендуемый (по умолчанию в Spring Boot).
- **Apache DBCP2** — зрелый и функциональный.
- **c3p0** — старый, используется реже сейчас.
- **Tomcat JDBC Pool** — часто используют в контейнерах.
Рекомендация: используйте **HikariCP** для новых проектов.
## Простой пример с HikariCP (Maven + Java)
**Maven**
```xml
<dependency>
  <groupId>com.zaxxer</groupId>
  <artifactId>HikariCP</artifactId>
  <version>5.0.1</version>
</dependency>
<!-- плюс драйвер СУБД, напр. PostgreSQL -->
<dependency>
  <groupId>org.postgresql</groupId>
  <artifactId>postgresql</artifactId>
  <version>42.5.0</version>
</dependency>
```
**Java-конфигурация и использование**
```java
import com.zaxxer.hikari.HikariConfig;
import com.zaxxer.hikari.HikariDataSource;

import javax.sql.DataSource;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;

public class HikariExample {
    private static HikariDataSource ds;

    static {
        HikariConfig cfg = new HikariConfig();
        cfg.setJdbcUrl("jdbc:postgresql://localhost:5432/mydb");
        cfg.setUsername("user");
        cfg.setPassword("pass");

        // Важные настройки
        cfg.setMaximumPoolSize(20);          // макс. активных соединений
        cfg.setMinimumIdle(5);               // поддерживать минимальное число
        cfg.setConnectionTimeout(30000);     // ms — ожидание свободного соединения
        cfg.setIdleTimeout(600000);          // ms — время простоя до закрытия
        cfg.setMaxLifetime(1800000);         // ms — максимум "жизни" соединения
        cfg.setLeakDetectionThreshold(2000); // ms — обнаружение утечек (debug)

        ds = new HikariDataSource(cfg);
    }

    public static DataSource getDataSource() {
        return ds;
    }

    public static void main(String[] args) throws Exception {
        try (Connection conn = getDataSource().getConnection();
             PreparedStatement ps = conn.prepareStatement("SELECT id, name FROM users WHERE active = ?");
        ) {
            ps.setBoolean(1, true);
            try (ResultSet rs = ps.executeQuery()) {
                while (rs.next()) {
                    System.out.println(rs.getInt("id") + " " + rs.getString("name"));
                }
            }
        }
        // при завершении приложения: ds.close();
    }
}
```
`HikariDataSource` реализует `DataSource` — слова `getConnection()` возвращает уже открытое соединение из пула.
## Настройки пула — на что обратить внимание
- `maximumPoolSize` — максимальное число одновременных соединений к БД. Устанавливайте с учётом возможностей БД и ожидаемой нагрузки.
- `minimumIdle` — минимальное количество готовых к использованию соединений.
- `connectionTimeout` — сколько ждать свободного соединения, прежде чем бросить исключение.
- `idleTimeout` — закрыть неиспользуемое соединение после этого времени.
- `maxLifetime` — принудительное обновление соединения; ставьте чуть меньше таймаута соединения на стороне БД.
- `leakDetectionThreshold` — полезно в диагностике: если соединение не возвращено дольше этого времени — лог/стек.
- `validationQuery` / `connectionTestQuery` — (для DBCP / Tomcat) строка для проверки корректности соединения; Hikari использует встроенные механизмы (isValid).
## Важные best-practices
1. **Всегда возвращайте соединение** (try-with-resources). Никогда не держите `Connection` дольше, чем нужно.
2. **Не закрывайте DataSource** пока приложение живо; закрывайте при выключении.
3. **Не ставьте `maxPoolSize` больше, чем DB выдержит** — это приведёт к очередям и таймаутам.
4. **Установите `maxLifetime` чуть меньше** запретов/таймаутов на стороне сервера (чтобы избежать "мертвых" соединений).
5. **Используйте prepared statements / кеш подготовленных выражений** (Hikari + драйвер поддерживают).
6. **Включите мониторинг / метрики** (Hikari предоставляет метрики через JMX).
7. **Используйте validation**: проверка соединения перед выдачей, либо `setConnectionInitSql`/`validationQuery`, чтобы избежать ошибок при использовании "висевших" соединений.
## Пример с Apache DBCP2 (если нужен альтернативный код)
```xml
<dependency>
  <groupId>org.apache.commons</groupId>
  <artifactId>commons-dbcp2</artifactId>
  <version>2.9.0</version>
</dependency>
```
```java
import org.apache.commons.dbcp2.BasicDataSource;

BasicDataSource ds = new BasicDataSource();
ds.setUrl("jdbc:postgresql://localhost:5432/mydb");
ds.setUsername("user");
ds.setPassword("pass");
ds.setMaxTotal(20);
ds.setMinIdle(5);
ds.setValidationQuery("SELECT 1");
```
## Spring Boot — очень простой способ
Spring Boot по умолчанию использует **HikariCP**. Достаточно в `application.properties`:
```properties
spring.datasource.url=jdbc:postgresql://localhost:5432/mydb
spring.datasource.username=user
spring.datasource.password=pass

# опции Hikari (prefix spring.datasource.hikari.*)
spring.datasource.hikari.maximum-pool-size=20
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000
```
В коде вы получаете `DataSource` или `JdbcTemplate` из контекста Spring.
## Мониторинг и отладка
- Включите логирование пула при проблемах.
- Используйте JMX или метрики (Prometheus) для наблюдения за количеством активных/ожидающих соединений, временем ожидания.
- Активируйте leak detection в тестовом окружении для поимки забытых `close()`.
## Частые ошибки и как их избегать
- `maxPoolSize` слишком большой → DB не справляется.
- Долгое удержание `Connection` (лепится к сессиям/ResultSet) → дефицит соединений.
- Отсутствие теста соединений → клиент получает "висевшие" соединения.
- Неучёт таймаутов БД → пул раздаёт соединения, которые сервер завершил (используйте maxLifetime/validation).
## Заключение / quick checklist
- Используйте готовый пул (HikariCP).
- Настройте `maximumPoolSize`, `connectionTimeout`, `maxLifetime`.
- Всегда освобождайте `Connection` (try-with-resources).
- Настройте health checks/validation и мониторинг.
- В Spring Boot — довольно просто: конфиг через `application.properties`/`application.yml`.