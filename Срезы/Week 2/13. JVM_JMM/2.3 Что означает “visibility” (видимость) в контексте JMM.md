В контексте **Java Memory Model (JMM)**, термин **“visibility” (видимость)** описывает **правило, гарантирующее, что изменения переменной, сделанные одним потоком, будут видны другим потокам в определённых условиях**.
### Подробно:
1. **Проблема без видимости:**  
    В Java каждый поток может кэшировать значения переменных в регистрах процессора или локальной памяти CPU (кэш).
    - Если поток A изменил переменную `x`, поток B может **не увидеть это изменение**, потому что он читает старое значение из своего кэша.
2. **Механизмы обеспечения видимости:**
    - **`volatile`**: Гарантирует, что чтение и запись переменной идут напрямую в main memory, и изменения одного потока **немедленно видны другим потокам**.
    - **Синхронизация (`synchronized`)**:
        - При входе в синхронизированный блок поток получает **“happens-before” гарантию**, т.е. все изменения, сделанные до выхода другого потока из блока с той же блокировкой, видны текущему потоку.
    - **Атомарные классы (`AtomicInteger`, `AtomicReference`, …)**: обеспечивают видимость через встроенные механизмы памяти и инструкции CPU.
3. **Happens-before и visibility:**  
    В JMM **“happens-before”** определяет порядок операций между потоками. Если операция A **happens-before** операции B, то **изменения, сделанные в A, гарантированно будут видны в B**.
**Пример:**
```java
class SharedData {
    volatile boolean flag = false; // volatile обеспечивает видимость
}

SharedData data = new SharedData();

// Поток 1
new Thread(() -> {
    data.flag = true; // изменение видно другим потокам
}).start();

// Поток 2
new Thread(() -> {
    if (data.flag) { // гарантированно увидит true
        System.out.println("Flag is true");
    }
}).start();
```
Если убрать `volatile`, поток 2 может **никогда не увидеть** изменение `flag`.