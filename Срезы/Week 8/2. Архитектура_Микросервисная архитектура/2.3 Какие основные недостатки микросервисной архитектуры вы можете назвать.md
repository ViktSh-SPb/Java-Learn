## ❌ **1. Сложность инфраструктуры**
Микросервисы требуют продуманной инфраструктуры:
- сервис-дискавери,
- балансировки нагрузки,
- мониторинга,
- логирования,
- CI/CD,
- оркестрации (Kubernetes).
Без этого система быстро превращается в хаос.
## ❌ **2. Повышенная сложность разработки**
В отличие от монолита, появляются новые задачи:
- сетевое взаимодействие между сервисами,
- сериализация/десериализация данных,
- управление версиями API,
- транзакции между сервисами (саги).
Это делает разработку значительно сложнее.
## ❌ **3. Сетевая задержка и ненадёжность сети**
Сервисы общаются по сети → это _не мгновенно_ и _не всегда надёжно_.  
Проблемы:
- таймауты,
- ошибки соединения,
- необходимость retry, circuit breaker.
## ❌ **4. Сложность отладки и трассировки**
Логика распределена между десятками сервисов.  
Чтобы понять, что произошло, нужно:
- собирать распределённые трассировки (Zipkin, Jaeger),
- анализировать корреляционные ID,
- просматривать логи из множества источников.
## ❌ **5. Управление данными становится сложным**
Каждый сервис обычно имеет **свою базу данных**.  
Трудности:
- согласованность данных,
- распределённые транзакции,
- дублирование данных,
- eventual consistency.
## ❌ **6. Рост количества сервисов = рост накладных расходов**
Чем больше сервисов, тем больше требуется:
- DevOps-ресурсов,
- конфигураций,
- тестов,
- документации,
- оркестрируемых окружений.
Часто поддержка системы становится дороже, чем монолита.
## ❌ **7. Требуются зрелые инженерные практики**
Командам нужно уметь:
- писать чистые API,
- проектировать границы сервисов,
- поддерживать совместимость версий,
- строить CI/CD и тестировать распределённые системы.
Без этого микросервисы быстро превращаются в распределённый монолит ("distributed monolith").