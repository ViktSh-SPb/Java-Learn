## ✅ Преимущества лямбда-выражений
### 1. Меньше кода → лучше читаемость
```java
// Анонимный класс
Runnable r = new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello");
    }
};

// Лямбда
Runnable r = () -> System.out.println("Hello");
```
### 2. Фокус на поведении, а не на реализации
Лямбды описывают **что делать**, а не **как устроен объект**.
```java
list.forEach(x -> System.out.println(x));
```
### 3. Идеальны для Stream API
Stream API фактически построен вокруг лямбд.
```java
list.stream()
    .filter(x -> x > 0)
    .map(x -> x * 2)
    .toList();
```
### 4. Меньше классов и мусора в проекте
- не создаются `*Impl`
- нет вложенных анонимных классов
- проще навигация по коду
### 5. Проще реализация паттернов
Strategy, Command, Comparator и др.:
```java
Comparator<String> c = (a, b) -> a.length() - b.length();
```
### 6. Нет собственного `this`
`this` указывает на внешний класс — часто **более ожидаемое поведение**.
## ❌ Недостатки лямбда-выражений
### 1. Ограничение функциональным интерфейсом
Лямбда:
- **только 1 абстрактный метод**
- нельзя реализовать несколько методов
Анонимный класс — можно.
### 2. Нельзя изменять локальные переменные
```java
int x = 0;
list.forEach(v -> x++); // ❌
```
В анонимных классах — то же ограничение, но часто ожидают другого поведения.
### 3. Падает читаемость при сложной логике
```java
// Плохо
list.forEach(x -> {
    if (x > 10) {
        doA();
        doB();
        doC();
    }
});
```
Здесь лучше:
- вынести метод
- или использовать анонимный класс / обычный метод
### 4. Сложнее отлаживать
- нет имени
- сложнее ставить breakpoint
- stack trace менее информативен
### 5. Нельзя объявлять состояние
В лямбде нельзя:
- объявить поля
- иметь конструктор
- хранить состояние
Анонимный класс это позволяет.
### 6. Неочевидность `this` и захвата переменных
```java
this.doSomething(); // this — внешний класс, не лямбда
```
Может быть неожиданно для новичков.
## ⚖️ Когда что использовать
### Используй **лямбды**, если:
✔ логика короткая  
✔ нужен функциональный интерфейс  
✔ работа со Stream API  
✔ одноразовое поведение
### Используй **анонимные классы**, если:
✔ нужно состояние  
✔ несколько методов  
✔ сложная логика  
✔ важна отладка
## Таблица сравнения

|Критерий|Лямбда|Анонимный класс|
|---|---|---|
|Объём кода|⭐⭐⭐|⭐|
|Читаемость|⭐⭐⭐|⭐⭐|
|Состояние|❌|✔|
|Несколько методов|❌|✔|
|`this`|внешний|собственный|
|Debug|сложнее|проще|
