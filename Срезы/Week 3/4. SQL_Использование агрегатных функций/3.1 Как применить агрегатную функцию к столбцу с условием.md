В SQL агрегатные функции (`SUM`, `COUNT`, `AVG`, `MAX`, `MIN` и т.д.) обычно применяются ко всем выбранным строкам, но **если нужно посчитать только для определённого подмножества**, используют **`WHERE`** или **условные выражения внутри агрегата**.
## 1️⃣ Через `WHERE`
Агрегат применяется после фильтрации строк условием.
```sql
-- Сумма зарплат только для сотрудников департамента 10
SELECT SUM(salary) AS total_salary
FROM employees
WHERE department_id = 10;
```
- Здесь сначала выбираются только строки, где `department_id = 10`, затем считается сумма.
## 2️⃣ Через `CASE` внутри агрегата
Позволяет применять агрегат к **определённым строкам, сохраняя все данные**.
```sql
-- Сумма зарплат только для департамента 10, но выводим по всем департаментам
SELECT department_id,
       SUM(CASE WHEN department_id = 10 THEN salary ELSE 0 END) AS sum_dept_10
FROM employees
GROUP BY department_id;
```
- `CASE` возвращает `salary` только для нужного условия, иначе 0.
- Можно использовать `NULL` вместо 0, если хотите игнорировать строки:
```sql
SUM(CASE WHEN department_id = 10 THEN salary END) AS sum_dept_10
```
## 3️⃣ Примеры для разных агрегатов
```sql
-- COUNT только для зарплат больше 5000
SELECT COUNT(*) AS high_salary_count
FROM employees
WHERE salary > 5000;

-- AVG только для сотрудников департамента 20
SELECT AVG(salary) AS avg_salary_dept20
FROM employees
WHERE department_id = 20;

-- MAX только для активных сотрудников
SELECT MAX(salary) AS max_active_salary
FROM employees
WHERE status = 'active';
```
✅ **Итог:**
- Используй `WHERE`, если фильтруешь строки перед агрегированием.
- Используй `CASE` внутри агрегата, если нужно условие **внутри агрегата**, особенно при `GROUP BY`.