**Лямбда-выражения** - это **анонимные функции**, которые позволяют кратко и выразительно реализовывать функциональные интерфейсы (интерфейсы с одним абстрактным методом). Они были добавлены в Java 8 и стали основой для функционального программирования в Java.
# Зачем нужны лямбда-выражения?
1. **Упрощение кода** - замена громоздких анонимных классов.
2. **Функциональное программирование** - поддержка операций в Stream API.
3. **Читаемость** - код становится более декларативным.
# Синтаксис
```java
(параметры) -> { тело }
```
## Варианты записи:
### 1. Без параметров:
```java
() -> System.out.println("Hello")
```
### 2. Один параметр (скобки можно опустить):
```java
x -> x * x
```
### 3. Несколько параметров:
```java
(a, b) -> a + b
```
### 4. Многострочное тело (фигурные скобки и return обязательны):
```java
(x, y) -> {
	int sum = x + y;
	return sum * 2;
}
```
## Примеры использования:
### 1. Замена анонимного класса:
#### Без лямбда-выражения:
```java
Runnable task = new Runnable() {
	@Override
	public void run() {
		System.out.println("Running...");
	}
};
```
#### С лямбда-выражением:
```java
Runnable task = () -> System.out.println("Running...");
```
### 2. Сортировка коллекции:
#### Без лямбда-выражения:
```java
Collections.sort(list, new Comparator<String>() {
	@Override
	public int compare(String a, String b) {
		return a.length() - b.length();
	}
});
```
#### С лямбда-выражением:
```java
Collections.sort(list, (a, b) -> a.length() - b.length());
```
### 3. Фильтрация в Stream API
```java
List<Integer> numbers = List.of(1, 2, 3, 4, 5);
List<Integer> evenNumbers = numbers.stream()
	.filter(x -> x % 2 == 0) // Лямбда-предикат
	.toList(); // [2, 4]
```
# Захват переменных
Лямбда может использовать:
- Локальные переменные (только *final* или *effectively final*)
- Поля класса (можно изменять)
### Пример:
```java
int factor = 2; // effectively final
Function<Integer, Integer> multiplier = x -> x * factor;
factor = 3; // Oшибка: factor должен быть неизменным
```
# Ссылки на методы (Method References)
Если лямбда просто вызывает метод, можно использовать " **::** "

| Тип               | Пример                | Эквивалентное лямбда-выражение |
| ----------------- | --------------------- | ------------------------------ |
| Статический метод | `Integer::parseInt`   | `s -> Integer.parseInt(s)`     |
| Метод экземпляра  | `System.out::pirntln` | `s -> System.out.println(s)`   |
| Конструктор       | `ArrayList::new`      | `() -> new ArrayList<>()`      |
# Ограничения
## Нельзя использовать:
1. *break*, *continue* (только внутри тела).
2. Не-*final* локальные переменные.
3. Перегрузку методов (лямбда - это реализация метода, а не новый метод).
