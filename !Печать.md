### **Индексы в SQL: полное руководство**

Индексы в SQL — это специальные структуры данных, которые ускоряют поиск, сортировку и фильтрацию записей в таблицах. Они работают аналогично оглавлению в книге: вместо полного сканирования таблицы (что медленно) СУБД использует индекс для быстрого доступа к данным.

---

## **1. Зачем нужны индексы?**
- **Ускорение `SELECT`-запросов** (особенно с `WHERE`, `JOIN`, `ORDER BY`, `GROUP BY`).  
- **Оптимизация уникальности** (уникальные индексы гарантируют отсутствие дублей).  
- **Ускорение сортировки** (индекс хранит данные в упорядоченном виде).  

### **Когда индексы не помогут?**
- На маленьких таблицах (сканирование может быть быстрее).  
- При частых `INSERT`/`UPDATE`/`DELETE` (индексы замедляют эти операции, т.к. их нужно перестраивать).  

---

## **2. Типы индексов**
### **1. B-дерево (B-Tree)**
- **Стандартный тип** в большинстве СУБД (PostgreSQL, MySQL, Oracle).  
- Подходит для:  
  - Точечных запросов (`WHERE id = 5`).  
  - Диапазонов (`WHERE age BETWEEN 20 AND 30`).  
  - Сортировки (`ORDER BY name`).  

**Пример создания:**  
```sql
CREATE INDEX idx_users_name ON users(name);
```

### **2. Хеш-индекс (Hash)**
- Работает **только для точных совпадений** (`WHERE id = 123`).  
- Не поддерживает диапазоны или сортировку.  
- Есть в PostgreSQL и MySQL (для InnoDB — только в режиме in-memory).  

**Пример:**  
```sql
CREATE INDEX idx_users_id_hash ON users USING HASH(id);
```

### **3. Bitmap-индекс**
- Используется в колоночных СУБД (ClickHouse, Greenplum).  
- Эффективен для столбцов с **малым количеством уникальных значений** (например, `gender`).  

### **4. Полнотекстовый индекс (FTS)**
- Для поиска по тексту (`LIKE '%keyword%'` в улучшенной версии).  
- Есть в PostgreSQL (`tsvector`), MySQL (`FULLTEXT`).  

**Пример:**  
```sql
CREATE INDEX idx_articles_content_fts ON articles USING GIN(to_tsvector('english', content));
```

### **5. Составной (композитный) индекс**
- Индекс по **нескольким столбцам**.  
- Порядок столбцов важен! Работает для запросов с левосторонним префиксом.  

**Пример:**  
```sql
CREATE INDEX idx_users_age_name ON users(age, name);
```
**Когда сработает:**  
- `WHERE age = 25 AND name = 'Alice'` (✅)  
- `WHERE age = 25` (✅)  
- `WHERE name = 'Alice'` (❌ не использует индекс)  

---

## **3. Когда создавать индексы?**
- **Часто используемые столбцы** в `WHERE`, `JOIN`, `ORDER BY`.  
- **Уникальные поля** (первичные и внешние ключи).  
- **Колонки с высокой селективностью** (много уникальных значений).  

### **Когда НЕ создавать?**
- На часто изменяемых столбцах (замедлит `INSERT`/`UPDATE`).  
- На столбцах с **NULL** (если не используется `WHERE column IS NOT NULL`).  

---

## **4. Просмотр и удаление индексов**
**Посмотреть индексы таблицы:**  
```sql
-- PostgreSQL
SELECT * FROM pg_indexes WHERE tablename = 'users';

-- MySQL
SHOW INDEX FROM users;
```

**Удалить индекс:**  
```sql
DROP INDEX idx_users_name;
```

---

## **5. Оптимизация индексов**
- **Используйте `EXPLAIN`** для анализа запросов.  
- **Мониторьте использование индексов** (в PostgreSQL — `pg_stat_user_indexes`).  
- **Перестраивайте индексы** при деградации производительности:  
  ```sql
  -- PostgreSQL
  REINDEX INDEX idx_users_name;
  
  -- MySQL
  ANALYZE TABLE users;
  ```

---

## **Вывод**  
Индексы — мощный инструмент для ускорения SQL-запросов, но их нужно применять с умом. Сначала анализируйте запросы, выбирайте правильный тип индекса и избегайте избыточности.