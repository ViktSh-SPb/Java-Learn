### Что такое GRASP?

GRASP (General Responsibility Assignment Software Principles) — это набор принципов и паттернов, предназначенных для определения ответственности и распределения задач между классами и объектами в объектно-ориентированном проектировании. Цель GRASP — помочь разработчикам принимать решения о том, кто должен выполнять определённые функции, чтобы обеспечить гибкую, расширяемую и поддерживаемую архитектуру.

### Перечислите основные принципы GRASP.

1. Information Expert (Эксперт информации) — ответственность за выполнение задачи должна быть возложена на тот класс, который обладает необходимыми данными.
2. Creator (Создатель) — класс, который создает объекты других классов, основываясь на связях и зависимостях.
3. Controller (Контроллер) — объект, отвечающий за обработку внешних запросов и координацию работы системы.
4. Low Coupling (Низкая связность) — минимизация зависимостей между классами для повышения модульности.
5. High Cohesion (Высокая связность) — классы должны иметь чётко определённую и связанную внутри ответственность.
6. Polymorphism (Полиморфизм) — использование наследования и переопределения методов для обработки вариаций поведения.
7. Protected Variations (Защита от вариаций) — минимизация влияния изменений в системе через использование интерфейсов и абстракций.

### Какие задачи решают принципы GRASP?

- Распределение ответственности между классами.
- Обеспечение гибкости и расширяемости системы.
- Уменьшение связности и повышение модульности.
- Облегчение поддержки и тестирования кода.
- Предотвращение "расползания" логики по разным частям системы.

### Как принцип эксперта информации (Information Expert) способствует определению ответственности в классах?

Этот принцип говорит, что ответственность за выполнение конкретной задачи должна быть возложена на тот класс, который обладает необходимыми данными для её выполнения. Например:

- Если нужно вычислить сумму заказа, лучше поручить это методу класса `Order`, так как он содержит список товаров и их цены. Это способствует тому, что классы имеют чётко определённые обязанности, уменьшается дублирование кода и повышается согласованность.

### Как принцип создатель (Creator) помогает определить, кто должен создавать экземпляры классов?

Принцип гласит:

- Класс `A` должен создавать объекты класса `B`, если:
    - `A` содержит или агрегирует объекты `B`.
    - ``A`тесно связан с`B`.
    - ``A`использует объекты`B` часто или управляет ими. Это помогает определить ответственного за создание объектов, что способствует более ясной архитектуре и уменьшению зависимости.

### Как принцип высокой связности (High Cohesion) влияет на проектирование классов?

Высокая связность означает, что класс выполняет узкоспециализированную задачу или группу связанных задач:

- Улучшает читаемость и понимание кода.
- Облегчает тестирование и сопровождение.
- Повышает повторное использование компонентов.
- Снижает вероятность ошибок при изменениях.

### Приведите пример применения принципа полиморфизма (Polymorphism) при рефакторинге кода.

Пример: Изначально у вас есть условный оператор:

```java
if (shapeType.equals("circle")) {
    // рисуем круг
} else if (shapeType.equals("rectangle")) {
    // рисуем прямоугольник
}
```

Рефакторинг с использованием полиморфизма:

```java
interface Shape {
    void draw();
}

class Circle implements Shape {
    public void draw() { /* рисование круга */ }
}

class Rectangle implements Shape {
    public void draw() { /* рисование прямоугольника */ }
}

// Использование
Shape shape = getShape(); // возвращает нужный объект
shape.draw();
```

Это позволяет добавлять новые фигуры без изменения существующего кода.

### Как принцип защиты от вариаций (Protection from Variations) помогает уменьшить влияние изменений в системе?

Этот принцип предполагает использование интерфейсов, абстракций или шаблонов проектирования для изоляции изменений:

- Внесение изменений в одну часть системы не вызывает каскадных ошибок.
- Повышается устойчивость системы к изменениям требований или реализации.
- Упрощается тестирование и сопровождение.

### В чем заключается принцип низкой связности (Low Coupling) и как он влияет на модульность и поддержку кода?

Принцип говорит о необходимости минимизировать зависимости между модулями или классами:

- Модули могут изменяться независимо друг от друга.
- Повышается повторное использование компонентов.
- Упрощается тестирование отдельных частей системы.
- Облегчается масштабирование и рефакторинг.

Итог: низкая связность способствует созданию гибкой архитектуры, которая легче адаптируется к изменениям.