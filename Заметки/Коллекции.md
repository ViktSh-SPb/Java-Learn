# Иерархия коллекций в Java

```mermaid
%% Иерархия коллекций Java (интерфейсы и классы)
classDiagram
  %% ===== Интерфейсы =====
  class Iterable:::interface
  class Collection:::interface
  class List:::interface
  class Set:::interface
  class SortedSet:::interface
  class Queue:::interface
  class Deque:::interface


  %% ===== Классы =====
  class ArrayList:::clazz
  class LinkedList:::clazz
  class Vector:::clazz
  class Stack:::clazz
  class HashSet:::clazz
  class LinkedHashSet:::clazz
  class TreeSet:::clazz
  class PriorityQueue:::clazz
  class ArrayDeque:::clazz

  %% ===== Наследование Collection =====
  Iterable <|-- Collection
  Collection <|-- List
  Collection <|-- Set
  Collection <|-- Queue
  List <|.. ArrayList
  List <|.. LinkedList
  List <|.. Vector
  Vector <|-- Stack
  Set <|.. HashSet
  Set <|.. LinkedHashSet
  Set <|-- SortedSet
  SortedSet <|.. TreeSet
  Queue <|.. PriorityQueue
  Queue <|-- Deque
  Deque <|.. ArrayDeque

classDef interface fill:#fdbf6e,stroke:#f66,stroke-width:2px,color:#111,stroke-dasharray: 10 5
classDef clazz fill:#aec670,stroke:#5ba199,stroke-width:2px,color:#111
```
# Set
**Set** - это интерфейс в Java, который представляет собой коллекцию, не содержащую дубликатов элементов.
## Основные характеристики:
- Не допускает дублирования элементов (все элементы уникальны)
- Может содержать не более одного *null* элемента.
- Не гарантирует порядок элементов (за исключением некоторых реализаций)
## Основные реализации Set:
### 1. HashSet:
- Наиболее часто используемая реализация
- Хранит элементы в хэш-таблице
- Не гарантирует порядок элементов
- Обеспечивает быстрый доступ к элементам (*О(1)* для основных операций)
- Потокобезопасна
```java
Set<String> hashSet = new HashSet<>();
hashSet.add("Apple");
hashSet.add("Banana");
hashSet.add("Apple"); // Не будет добавлено
```
### 2. LinkedHashSet:
- Сохраняет порядок вставки элементов
- Для хранения элементов используется комбинация связного списка и хэш-таблицы
- Немного медленнее *HashSet* из-за дополнительных затрат на поддержание связного списка
- Полезен когда важен порядок итерации
```java
Set<String> linkedHashSet = new LinkedHashSet<>();
linkedHashSet.add("First");
linkedHashSet.add("Second");
linkedHashSet.add("Third");
// Итерация будет в порядке добавления
```
### 3. TreeSet
- Хранит элементы в отсортированном порядке (по возрастанию)
- Реализован на основе красно-черного дерева
- Время выполнения операции *О(log n)*
- Может использовать Comparator для сортировки
```java
Set<String> treeSet = new TreeSet<>();
treeSet.add("Zebra");
treeSet.add("Apple");
treeSet.add("Banana");
// Элементы будут отсортированы: Apple, Banana, Zebra
```
## Основные методы Set:
```java
set.add(E e);             // Добавляет элемент, если его еще нет в множестве
set.remove(Object o);     // Удаляет указанный элемент
set.contains(Object o);   // Проверяет наличие элемента
set.size();               // Возвращает количество элементов
set.isEmpty;              // Возвращает логический ответ, пуст ли набор
set.clear();              // Удаляет все элементы
set.iterator();           // Возвращает итератор по элементам
```
## Особенности использования:
1. Проверка на дубликаты: *Set* использует методы *equals() и hashCode()* для определения дубликатов. Поэтому важно правильно их реализовать для объектов, которые вы храните в *Set*.
2. Сравнение с *List*:
	- *List* допускает дубликаты, *Set* - нет.
	- *List* сохраняет порядок вставки (кроме некоторых реализаций), *Set* - не всегда
	- Доступ по индексу есть только в *List*
3. Потокобезопасность: Стандартные реализации *Set* не потокобезопасны. Для многопоточного доступа можно использовать:
	- `Collections.synchronizedSet(new HashSet<>())`
	- `CopyOnWriteArraySet` (для редко изменяемых наборов)
	- `ConcurrentHashMap.newKeySet()`
# ArrayList
**ArrayList** - это реализация динамического массива, который позволяет хранить элементы и автоматически изменять свой размер при добавлении или удалении элементов. Это одна из самых популярных коллекций в Java, так как она сочетает в себе удобство списка и эффективность массива.
## Основные характеристики ArrayList
- ✅ **Динамический размер** - автоматически расширяется при добавлении элементов.
- ✅ **Быстрый доступ по индексу** - *О(1)* (как в обычном массиве).
- ✅ **Поддержка generics** - типобезопасность (*ArrayList\<Integer>, ArrayList\<String>*).
- ✅ **Допускает null и дубликаты**.
- ❌ **Медленная вставка/удаление в середину** - *О(n)* (из-за сдвига элементов).
## Внутреннее устройство ArrayList
Внутри *ArrayList* хранит элементы в обычном массиве (*Object[]*).
- При создании *ArrayList* имеет начальную емкость (10)
- Если массив заполняется, происходит расширение (*resize*) - создается новый массив в 1.5 раза больше (в *Java 7+*) и копируются старые элементы.
## Основные операции и их сложность

| Операция                | Сложность (О)               | Пояснение                                    |
| ----------------------- | --------------------------- | -------------------------------------------- |
| get(index)              | O(1)                        | Прямой доступ к элементу                     |
| add(element)            | O(1)&nbsp(амортизированная) | Добавление в конец, если места хватает       |
| add(index,&nbspelement) | O(n)                        | Вставка в середину требует сдвига элементов  |
| remove(index)           | O(n)                        | Удаление по индексу требует сдвига элементов |
| remove(Object)          | O(n)                        | Поиск элемента + сдвиг                       |
| contains(Object)        | O(n)                        | Линейный поиск (нет хеширования)             |
| set(index, element)     | O(1)                        | Замена элемента по индексу                   |
## Создание ArrayList
```java
import java.util.ArrayList

// 1. Создание пустого списка (начальная емкость = 10)
ArrayList<String> list1 = new ArrayList<>();

// 2. Создание с указанием начальной емкости (оптимизация, если известно количество элементов)
ArrayList<Integer> list2 = new ArrayList<>(100);

// 3. Создание из другой коллекции
ArrayList<String> list3 = new ArrayList<>(List.of("A", "B", "C"));
```
## Основные методы
### 1. Добавление элементов
```java
ArrayList<String> fruits = new ArrayList<>();
fruits.add("Apple");       // ["Apple"]
fruits.add("Banana");      // ["Apple", "Banana"]
fruits.add(1, "Orange");   // ["Apple", "Orange", "Banana"] (вставка по индексу)
```
### 2. Получение элементов
```java
String first = fruits.get(0); // Apple
int size = fruits.size();     // 3
```
### 3. Удаление элементов
```java
fruits.remove(0);         // Удаляет "Apple" ⟶ ["Orange", "Banana"]
fruits.remove("Banana");  // Удаляет "Banana" ⟶ ["Orange"]
fruits.clear();           // Очищает список ⟶ []
```
### 4. Проверка наличия элементов
```java
boolean hasApple = fruits.contains("Apple"); // false
int index = fruits.indexOf("Orange");        // 0
```
### 5. Итерация по ArrayList
```java
// через for-each
for (String fruit : fruits) {
	System.out.println(fruit);
}

// через for + индекс
for (int i = 0; i < fruits.size(); i++) {
	System.out.println(fruits.get(i));
}

// через итератор
Iterator<String> it = fruits.iterator();
while (it.hasNext()) {
	System.out.println(it.next());
}
```
## Преимущества и недостатки
### ✅Плюсы:
- Быстрый доступ по индексу (*get, set*)
- Удобные методы для работы с данными (*add, remove, contains*)
- Гибкость (размер меняется автоматически)
### ❌Минусы:
- Медленные вставка и удаление в середину (*О(n)*)
- Тратит дополнительную память (резервирует место в массиве)
- Не синхронизирован (не потокобезопасен, в отличие от *Vector*)
# Map
Коллекции типа **Map** представляют собой структуры данных, которые хранят пары ключ-значение (*key-value*). Они не являются частью интерфейса *Collection*, но входят в *Java Collections Framework*.
## Основные характеристики Map
1. **Уникальность ключей** - каждый ключ может встречаться только один раз.
2. **Доступ по ключу** - значения извлекаются не по индексу, а по ключу.
3. **Порядок элементов** - зависит от конкретной реализации (может быть неупорядоченным, отсортированным или сохранять порядок добавления).
## Основные реализации Map
### 1. HashMap (наиболее популярна)
**HashMap** состоит из массива корзин (*buckets*), каждая из которых содержит связный список (или красно-черное дерево в Java 8+ для улучшения производительности при коллизиях).
- **Хранение:** Хранит данные в хеш-таблице.
- **Порядок:** Не гарантирует порядок элементов.
- **Производительность:**
	- *get()* и *put()* - в среднем *О(1)* (если нет коллизий).
	- В худшем случае (все ключи в одном бакете) - *О(n)*.
- **Допустимые ключи:** Любые объекты (но лучше использовать неизменяемые), *null* разрешен.
- **Использование:**
```java
Map<String, Integer> map = new HashMap<>();
map.put("apple", 10);
map.put("banana", 20);
System.out.println(map.get("apple")); // 10
```
#### Структура HashMap
```java
HashMap
|
|-- Bucket 0 -> [Entry<K, V>] -> [Entry<K, V>] -> ... (LinkedList/Tree)
|-- Bucket 1 -> [Entry<K, V>] -> ...
|-- ...
|-- Bucket N -> [Entry<K, V>] -> ...
```
Каждый элемент (Entry или Node) хранит:
- Ключ (Key)
- Значение (Value)
- Хеш ключа (hash)
- Ссылка на следующий элемент (если есть коллизия)
### 2. LinkedHashMap (сохраняет порядок добавления)
- **Хранение:** Хеш-таблица + двусвязный список для порядка.
- **Порядок:** Сохраняет порядок вставки (или порядок доступа, если *accessOrder = true*).
- **Производительность:** Чуть медленнее *HashMap* из-за поддержки порядка.
- **Использование:**
```java
Map<String, Integer> map = new LinkedHashMap<>();
map.put("apple", 10);
map.put("banana", 20);
System.out.println(map); // {apple = 10, banana = 20} (порядок сохранен)
```
### 3. TreeMap (сортировка по ключам)
- **Хранение:** Красно-черное дерево (автоматическая сортировка).
- **Порядок:** Элементы сортируются по ключу (естественный порядок или *Comparator*).
- **Производительность:** *get()* и *put()* - *О(log n)*.
- **Допустимые ключи:** Должны реализовывать  *Comparable* или передаваться *Comparator*.
- **Использование:**
```java
Map<String, Integer> map = new TreeMap<>();
map.put("banana", 20);
map.put("apple", 10);
System.out.println(map); // {apple=10, banana=20} (отсортировано)
```
### 4. Hashtable (устаревший, потокобезопасный)
- **Хранение:** Хеш-таблица, как *HashMap*.
- **Особенности:**
	- Потокобезопасный (все методы *synchronized*).
	- Не допускает *null* ни в ключах, ни в значениях.
	- Медленнее *HashMap* из-за синхронизации.
- **Использование:**
```java
Map<String, Integer> map = new Hashtable<>();
map.put("apple", 10);
System.out.println(map.get("apple")); // 10
```
### 5. ConcurrenthashMap (современная потокобезопасная замена Hashtable)
- **Хранение:** Сегментированная хеш-таблица (блокировка на уровне сегментов).
- **Особенности:**
	- Высокая производительность в многопоточной среде.
	- Допускает *null* в значениях (но не в ключах).
	- Лучше *Hashtable* и *Collections.synchronizedMap()*.
- **Использование:**
```java
Map<String, Integer> map  = new ConcurrentHashMap<>();
map.put("apple", 10);
System.out.println(map.get("apple")); // 10
```
### Другие полезные Map-реализации

| Класс           | Описание                                                                         | Особенности                 |
| --------------- | -------------------------------------------------------------------------------- | --------------------------- |
| WeakHashMap     | Ключи хранятся по слабым ссылкам (могут быть удалены GC, если нет других ссылок) | Полезно для кэшей           |
| IdentityHashMap | Сравнение ключей через == а не equals()                                          | Используется в сериализации |
| EnumMap         | Оптимизирован для enum-ключей                                                    | Быстрее HashMap для enum    |
## Основные методы Map
```java
map.put(key, value);         // Добавить/заменить пару
map.get(key);                // Получить значение по ключу
map.containsKey(key);        // Проверить наличие ключа
map.containsValue(value);    // Проверить наличие значения
map.remove(key);             // Удалить пару
map.keySet();                // Множество ключей
map.values();                // Коллекция значений
map.entrySet();              // Множество пар (Entry)
```
## Процесс добавления элемента (put)
Когда вызывается `map.put(key, value)`, происходит следующее:
### Шаг 1: Вычисление хеша ключа
1. Вычисляется хеш-код ключа с помощью метода *hashCode()*.
2. Этот хеш дополнительно "перемешивается" (через `hash ^ (hash >>> 16)`), чтобы уменьшить коллизии.
	- *null* всегда имеет хеш 0 и хранится в первой корзине.
```java
static final int hash(Object key) {
	int h;
	return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
### Шаг 2: Определение корзины (bucket)
Вычисляется индекс корзины, куда попадет элемент:
```java
int index = (n - 1) & hash; // n - размер массива корзин (степень двойки)
```
- *n* - всегда степень двойки (16, 32, 64, ...), поэтому` (n - 1) & hash` эквивалентно `hash % n`, но работает быстрее.
### Шаг 3: Поиск элемента в корзине
1. Если корзина пустая - создается новый *Node* и  добавляется туда.
2. Если корзина не пустая - происходит проверка ключей:
	1. Если ключ уже существует (по *equals()*), его значение перезаписывается.
	2. Если ключ новый, элемент добавляется в конец связного списка (или в красно-черное дерево, если список слишком большой).
### Шаг 4: Проверка на необходимость расширения (resize)
Если *HashMap* заполнен на 75% (по умолчанию), происходит увеличение размера:
1. Создается новый массив вдвое больше.
2. Все элементы перехешируются и перераспределяются по новым корзинам.
## Коллизии и как они обрабатываются
Коллизия - ситуация, когда разные ключи попадают в одну корзину (из-за одинакового *hashCode* или после` & (n - 1)`).
### Java 7: Связные списки
- Элементы с коллизиями хранятся в односвязном списке.
- При большом количестве коллизий поиск замедляется до *О(n)*.
### Java 8+: Красно-черные деревья (при больших коллизиях)
- Если список в корзине становится длиннее 8 элементов, он преобразуется в красно-черное дерево (поиск за *О(log n)*).
- Если размер уменьшается до 6 элементов, дерево снова превращается в список.
```java
// Пример коллизии:
map.put("Aa", 1); // Хеш "Aa" = 2112
map.put("Bb", 2); // Хеш "Bb" = 2112 (коллизия)
```
## Что происходит при putIfAbsent?
Метод **putIfAbsent** сначала проверяет наличие ключа:
```java
if (map.get(key) == null) {
	map.put(key, value);
}
```
В отличие от *put*, он не перезаписывает существующее значение.
## Временная сложность операций

| Операция | Средний случай (О) | Худший случай (О) |
| -------- | ------------------ | ----------------- |
| put()    | O(1)               | O(log n)*         |
| get()    | O(1)               | O(log n)*         |
| remove() | O(1)               | O(log n)*         |
**(\*)** - В Java 8+ при использовании деревьев вместо списков.