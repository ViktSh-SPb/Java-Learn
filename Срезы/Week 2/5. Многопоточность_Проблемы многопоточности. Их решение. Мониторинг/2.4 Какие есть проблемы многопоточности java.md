## 1️⃣ **Состояние гонки (Race Condition)**
- Возникает, когда **несколько потоков одновременно обращаются к общему ресурсу без синхронизации**.
- Итог зависит от порядка выполнения потоков.
- Пример: инкремент общей переменной (`counter++`) может "теряться".
**Решение:** `synchronized`, `ReentrantLock`, атомарные классы (`AtomicInteger`).
## 2️⃣ **Взаимная блокировка (Deadlock)**
- Поток **ждёт ресурс**, который захвачен другим потоком, а другой поток ждёт первый ресурс → все блокируются.
- Часто возникает при **нескольких блокировках в разном порядке**.
**Решение:**
- Брать блокировки в **одном и том же порядке**.
- Использовать таймауты (`tryLock(timeout)`).
- Использовать высокоуровневые синхронизаторы (`Semaphore`, `Phaser`).
## 3️⃣ **Голодание потоков (Starvation)**
- Поток **долго не получает доступ к ресурсу**, потому что другие потоки постоянно его занимают.
- Возникает, если **потоки с более высоким приоритетом "перекрывают" низкоприоритетные**.
**Решение:** балансировка приоритетов, использование справедливых блокировок (`ReentrantLock(true)` — fair).
## 4️⃣ **Живое ожидание (Livelock)**
- Потоки активно реагируют друг на друга, но **никакая работа не выполняется**.
- Отличие от deadlock: потоки **не блокируются**, а постоянно изменяют состояние, мешая друг другу.
**Решение:** добавить небольшие задержки, корректно проектировать алгоритм.
## 5️⃣ **Проблемы видимости (Visibility Issues)**
- Поток A изменяет переменную, но поток B **не видит обновление**.
- Возникает из-за **кэширования переменных в регистрах процессора или CPU cache**.
**Решение:**
- Ключевое слово `volatile`.
- Синхронизированные блоки (`synchronized`).
- Атомарные классы (`AtomicInteger`).
## 6️⃣ **Ошибки управления потоками**
- Создание слишком большого количества потоков → **падение производительности или OutOfMemoryError**.
- Неправильное завершение потоков → ресурсы остаются заблокированными.
**Решение:** использовать **ThreadPool / ExecutorService**, корректно закрывать потоки (`shutdown()`).
## 7️⃣ **Утечки памяти через ThreadLocal**
- Если `ThreadLocal` не очищать в пуле потоков, **данные остаются привязанными к потоку**, вызывая утечки.
**Решение:** `threadLocal.remove()` после использования.
## 8️⃣ **Проблемы с блокирующими структурами**
- Некорректное использование `BlockingQueue`, семафоров, `CountDownLatch` → **зависание потоков**.
- Например, поток ожидает `take()`, а другие потоки никогда не делают `put()`.
### ✅ Итог
Проблемы многопоточности сводятся к четырём основным группам:
1. **Конкуренция за ресурсы** → race condition, visibility.
2. **Блокировки и координация** → deadlock, livelock, starvation.
3. **Ошибки управления потоками** → слишком много потоков, неправильное завершение.
4. **Особенности инструментов Java** → ThreadLocal утечки, неправильное использование синхронизаторов.