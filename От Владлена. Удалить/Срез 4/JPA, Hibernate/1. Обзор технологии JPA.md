## Что такое JPA и для чего она используется?

JPA (Java Persistence API) — это стандартный интерфейс Java для работы с объектно-реляционной маппингом (ORM). Он определяет набор правил и API для взаимодействия с базой данных, позволяя разработчикам работать с объектами Java вместо написания низкоуровневого SQL.

Основная цель JPA: упростить работу с базой данных, автоматизировать преобразование объектов Java в таблицы и строки базы данных, а также управлять жизненным циклом этих объектов.

Использование JPA:

- Определение сущностей (классов, отображающих таблицы).
- Выполнение CRUD-операций (создание, чтение, обновление, удаление).
- Управление транзакциями.
- Выполнение запросов к базе данных через JPQL или Criteria API.

---

## Какие основные преимущества использования JPA по сравнению с JDBC?

|Преимущество|Описание|
|---|---|
|Объектно-ориентированный подход|Работаете с объектами Java вместо написания SQL-запросов.|
|Автоматический маппинг|Автоматическая связь классов и таблиц, полей и столбцов.|
|Упрощение кода|Меньше шаблонного кода для выполнения операций CRUD.|
|Поддержка транзакций|Встроенная поддержка транзакций и управление ими.|
|Кросс-платформенность|Возможность менять реализации JPA (например, Hibernate, EclipseLink) без изменения бизнес-логики.|
|Ленивая загрузка и кеширование|Возможность оптимизации работы с данными через кеши и ленивую загрузку.|
|Поддержка сложных запросов|Использование JPQL или Criteria API для сложных запросов без написания SQL вручную.|

В отличие от JDBC, где вы пишете SQL-запросы вручную и управляете ресурсами (соединениями, результатами), JPA скрывает эти детали и работает на уровне объектов.

---

## Как определить сущность в JPA?

Чтобы объявить класс как сущность:

1. Помечаете класс аннотацией `@Entity`.
2. Обязательно задаёте уникальный идентификатор (`@Id`).
3. Можно использовать аннотации `@Table`, чтобы указать имя таблицы (если оно отличается от имени класса).

### Пример:

```java
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Table;

@Entity
@Table(name = "users") // необязательно, если имя совпадает
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private String email;

    // геттеры и сеттеры
}
```

### Ключевые моменты:

- `@Entity` — объявляет класс как сущность.
- `@Id` — указывает поле как первичный ключ.
- `@GeneratedValue` — автоматическая генерация значения ID.
- Можно добавлять другие аннотации для настройки маппинга.

## Какие стратегии наследования поддерживает JPA?

JPA поддерживает несколько стратегий наследования для отображения иерархий классов в таблицы базы данных:

1. Single Table (одна таблица для всей иерархии)
    
    - Все классы в иерархии хранятся в одной таблице.
    - Используется аннотация `@Inheritance(strategy = InheritanceType.SINGLE_TABLE)`
    - Поле `@DiscriminatorColumn` определяет тип объекта.
2. Joined (таблицы для каждого класса, связанные по ключу)
    
    - Каждому классу соответствует отдельная таблица, связанные через внешние ключи.
    - Используется `@Inheritance(strategy = InheritanceType.JOINED)`.
3. Table per Class (таблица для каждого класса, без объединения)
    
    - Каждая сущность имеет свою таблицу, содержащую все поля.
    - Используется `@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)`.

---

## Как реализовать отношения один-ко-многим в JPA?

Для отображения отношения один-ко-многим используют аннотацию `@OneToMany`. Обычно:

```java
@Entity
public class Parent {
    @Id
    private Long id;

    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
    private List<Child> children;
}

@Entity
public class Child {
    @Id
    private Long id;

    @ManyToOne
    @JoinColumn(name = "parent_id")
    private Parent parent;
}
```

Объяснение:

- В классе `Parent` есть коллекция `children`, помеченная `@OneToMany`.
- В классе `Child` есть ссылка на `Parent`, помеченная `@ManyToOne`.
- Параметр `mappedBy` указывает, что отношение управляется стороной `Child`.

---

## Как работает кэширование в JPA и какие типы кэшей поддерживаются?

JPA поддерживает два уровня кэширования:

1. Первый уровень (постоянный кэш) — встроен в EntityManager и работает только в рамках его жизненного цикла. Он автоматически кеширует объекты, которые были загружены или сохранены через текущий EntityManager.
    
2. Второй уровень (глобальный кэш) — глобальный для всего `EntityManagerFactory`. Позволяет кешировать объекты между транзакциями и сессиями, повышая производительность при повторных запросах.
    

Поддерживаемые типы кэшей:

- Встроенные реализации (например, Hibernate имеет свой второй уровень кэша).
- Можно подключать внешние системы кеширования (например, Ehcache, Infinispan).

Настройка второго уровня кэша:

- В конфигурации указывается использование кеша.
- Можно аннотировать сущности `@Cacheable(true)` и настроить стратегию кеширования (`READ_WRITE`, `READ_ONLY`, etc.).

---

## Как можно интегрировать пользовательские SQL-запросы в JPA?

Используются методы:

- `@NamedNativeQuery` — объявление нативных SQL-запросов с именами.
- `EntityManager.createNativeQuery()` — динамическое создание нативных SQL-запросов.

Пример:

```java
String sql = "SELECT * FROM users WHERE email = ?";
Query query = entityManager.createNativeQuery(sql, User.class);
query.setParameter(1, email);
User user = (User) query.getSingleResult();
```

Также можно использовать DTO-проекции или маппинг результатов вручную.

---

## Какие подходы к оптимистичной и пессимистичной блокировке поддерживаются в JPA?

### Оптимистичная блокировка

Использует версионное поле (`@Version`) для обнаружения конфликтов при одновременной работе:


```java
@Entity
public class Product {
    @Id
    private Long id;

    @Version
    private int version;

    // остальные поля
}
```

При обновлении JPA проверяет версию; если она изменилась — выбрасывает исключение (`OptimisticLockException`).

### Пессимистичная блокировка

Обеспечивает блокировку данных на уровне базы данных во время транзакции:

```java
entityManager.find(Product.class, id, LockModeType.PESSIMISTIC_WRITE);
```

или

```java
Query query = entityManager.createQuery("SELECT p FROM Product p WHERE p.id = :id");
query.setLockMode(LockModeType.PESSIMISTIC_WRITE);
```

Поддерживаются режимы:

- PESSIMISTIC_READ
- PESSIMISTIC_WRITE
- PESSIMISTIC_FORCE_INCREMENT

---

## Как реализовать мульти-тенантность в приложении с использованием JPA?

Мульти-тенантность — это возможность работы с несколькими клиентами или арендаторами в одном приложении.

Подходы:

1. Столбец "tenant_id" — добавление поля в каждую таблицу:
    - В каждой сущности добавляется поле tenantId.
    - Используются глобальные фильтры или условия (`WHERE tenant_id = ?`) при запросах.
2. Шаблон "Schema per tenant" — отдельная схема/база данных для каждого клиента:
    - Конфигурируется DataSource для каждой схемы.
3. Использование Hibernate Multi-Tenancy:
    - Hibernate поддерживает разные стратегии мульти-тенантности:
        - DATABASE: каждая аренда — отдельная база данных.
        - SCHEMA: каждая аренда — отдельная схема.
        - DISCRIMINATOR: один набор таблиц с полем tenant_id.

Пример реализации с Hibernate:

```java
// Настройка MultiTenancyStrategy при конфигурации SessionFactory
properties.put(Environment.MULTI_TENANT, MultiTenancyStrategy.SCHEMA);
```

И далее реализуется интерфейс `CurrentTenantIdentifierResolver`, который возвращает текущего арендатора.