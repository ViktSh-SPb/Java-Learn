### Что такое заглушка (stub) в контексте модульного тестирования?

Заглушка (stub) — это упрощенная реализация компонента или зависимости, которая возвращает заранее заданные значения или имитирует поведение, необходимое для проведения теста. Она используется для изоляции тестируемого кода от внешних систем или сложных зависимостей.

### Какова основная цель использования заглушек в тестировании?

Основная цель:

- Изоляция тестируемого компонента от внешних зависимостей.
- Контроль над поведением зависимостей, чтобы обеспечить предсказуемость и повторяемость тестов.
- Обеспечение возможности тестирования в условиях, когда реальные объекты недоступны, сложны или медленны.
- Имитация сценариев ошибок или исключений, которые трудно воспроизвести с реальными объектами.

## В чем разница между заглушками и макетами (mocks)?

|Характеристика|Заглушка (Stub)|Макет (Mock)|
|---|---|---|
|Основная роль|Возвращает предопределенные значения|Проверяет взаимодействия, вызовы методов|
|Поведение|Статичное, заранее заданное|Динамическое, с проверками вызовов|
|Использование|Для возврата данных|Для проверки взаимодействий и вызовов методов|
|Пример|Метод возвращает фиксированный результат|Метод ожидает вызова с определенными аргументами|

Кратко:

- Заглушки — это "подставные" объекты, которые возвращают фиксированные данные.
- Моки — это объекты, которые не только предоставляют данные, но и проверяют, что с ними взаимодействуют правильно.

### Какие есть типы заглушек и в чем их основные отличия?

Основные типы:

1. Simple Stub (Простая заглушка) — возвращает фиксированные значения без логики проверки вызовов.
2. Conditional Stub (Условная заглушка) — возвращает разные значения в зависимости от входных параметров.
3. Behavioral Stub (Поведенческая заглушка) — имитирует поведение системы, включая исключения или задержки.

Отличия:

- Простые обычно статичны и не меняют поведения.
- Условные могут менять ответы в зависимости от условий.
- Поведенческие могут имитировать сложное поведение системы или ошибок.

### Как заглушка может быть использована для имитации исключений в тестах?

Пример:

```java
public class MyServiceStub extends MyService {
    @Override
    public Data fetchData() {
        throw new RuntimeException("Simulated exception");
    }
}
```

или с помощью фреймворков:

```java
when(dependency.method()).thenThrow(new RuntimeException("Error"));
```

Это позволяет проверить обработку ошибок в тестируемом коде.

### В каких случаях предпочтительнее использовать заглушки, а не реальные объекты в тестировании?

- Когда реальные объекты недоступны или их использование затруднено (например, внешние системы).
- Для изоляции тестируемого компонента от нестабильных или медленных зависимостей.
- Для моделирования сценариев ошибок или редких случаев.
- Для ускорения выполнения тестов.
- Когда необходимо контролировать поведение зависимостей точно и предсказуемо.

### Как реализовать параметризированную заглушку с использованием фреймворка для тестирования на Java?

Можно использовать `@ParameterizedTest` из JUnit 5 вместе с фабриками данных:

```java
@ParameterizedTest
@CsvSource({
    "input1, expectedOutput1",
    "input2, expectedOutput2"
})
void testWithParameterizedStub(String input, String expected) {
    MyDependency dependency = new MyDependency() {
        @Override
        public String process(String data) {
            // Возвращаем предопределенный результат на основе входных данных
            if ("input1".equals(data)) return "expectedOutput1";
            if ("input2".equals(data)) return "expectedOutput2";
            return null;
        }
    };
    // Используйте dependency в вашем тесте
}
```

Или создавайте фабрики-заглушки:

```java
public class MyStubFactory {
    public static MyDependency createStub(String scenario) {
        return new MyDependency() {
            @Override
            public String process(String data) {
                switch(scenario) {
                    case "success": return "ok";
                    case "error": throw new RuntimeException("Error scenario");
                    default: return null;
                }
            }
        };
    }
}
```

### Можете ли вы привести пример использования заглушек для тестирования взаимодействия между слоями приложения?

Допустим, у вас есть сервис `OrderService`, который вызывает `PaymentGateway`. В тесте можно создать заглушку `PaymentGateway`:

```java
public class PaymentGatewayStub implements PaymentGateway {
    private boolean wasCalled = false;

    @Override
    public PaymentResponse processPayment(PaymentRequest request) {
        wasCalled = true;
        return new PaymentResponse(true);
    }

    public boolean wasCalled() {
        return wasCalled;
    }
}

@Test
public void testOrderProcessing() {
    PaymentGatewayStub stub = new PaymentGatewayStub();
    OrderService orderService = new OrderService(stub);

    orderService.placeOrder(order);

    assertTrue(stub.wasCalled(), "Payment gateway should be invoked");
}
```

Это позволяет проверить взаимодействие без реального платежного сервиса.

### Какие принципы следует учитывать при проектировании заглушек для обеспечения их эффективного использования?

- Ясность и простота: Заглушки должны быть легко читаемыми и понятными.
- Изоляция: Не должны иметь побочных эффектов вне теста.
- Гибкость: Возможность задавать разные сценарии поведения.
- Минимизация логики: Заглушки должны содержать минимальную логику — только то, что необходимо для теста.
- Повторное использование: Можно создавать универсальные фабрики или шаблоны для разных сценариев.
- Обеспечение предсказуемости: Возвращать ожидаемые результаты для каждого сценария.